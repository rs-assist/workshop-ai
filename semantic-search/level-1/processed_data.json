{
  "chunks": [
    "Șiruri \n \nExistă trei clase referitoare la şiruri:  String ,  StringBuffer si StringBuilder.  Diferenţa \nconstă dans faptul că obiectele de tipul String sunt imutabile , iar cele de tip StringBuffer sau \nStringBuilder  sunt mutabile (pot fi modificate).  \nClasa StringBuffer  este sigur a in aplicatiile concurente in timp ce StringBuilder  nu. In \ngeneral vom utiliza StringBuilder  in aplicatii cu un singur Thread.  \nComparativ cu StringBuffer  clasa StringBuilder  va fi utilizata  cu precadere datorita vitezei \nmai mari.  \nClasa String  \nOrice constantă şir este transformată într -o instanţă a clasei String , fiind echivalentă cu  new \nString(constanta_sir).  \n \n String s=”Exemplu”;  \n \nÎn această declaraţie este construit implicit un obiect String, fără a fi nevoie de a apela new \nString(”Exemplu” ). \n \nOperaţii  \n- Operatorii + şi += realizează concatenarea şirurilor  \n- int length() – numărul de caractere din şir  \n- char charAt(i)  – caracterul c u indicele i din sir  \n- int indexO",
    "”Exemplu” ). \n \nOperaţii  \n- Operatorii + şi += realizează concatenarea şirurilor  \n- int length() – numărul de caractere din şir  \n- char charAt(i)  – caracterul c u indicele i din sir  \n- int indexOf(c)  – indicele caracterului c  \n- String substring(i,j)  – returnează subşirul care începe cu caracterul de indice i al şirului \nşi se termină cu carcaterul de indice j-1  \n-     String replace(char c1, char c2)  – returnează un şir  în care c1 este înlocuit cu c2  \n- valueOf() realizează conversia unei valori într -un şir  \nExemplu \n       boolean p = true;  \n       int n = 10;  \n       double x = 6.023;  \n        String sp = String.valueOf(p); //”true”  \n        String sn = String.valueOf(n); //”10”  \n        String sx = String.valueOf(x); //”6.023”  \n \nCompararea a două şiruri poate fi efectuată cu una din metodele  \n- boolean equals()    \n- boolean equalsIgnoreCase()  \n- int compareTo() similar cu strcmp() din biblioteca C.",
    "alueOf(x); //”6.023”  \n \nCompararea a două şiruri poate fi efectuată cu una din metodele  \n- boolean equals()    \n- boolean equalsIgnoreCase()  \n- int compareTo() similar cu strcmp() din biblioteca C.  \nAtenţie : operatorul == verifică egalitatea referinţelor nu şi a conţinutului  \n \nExemplu  \nclass siruri {  \n  public static void main(String [] args)  \n  { \n    String s1=\"ABCdefgh\", so=s1;  \n \n    System.out.println(\"String s1= \\\"\"+ s1 +\" \\\", so=s1\"); \n    System.out.println(\"s1.length :\"+ s1.length() );  \n    System.out.println(\"s1.charAt(1) :\"+ s1.charAt(1) );  \n    System.out.println(\"s1.substring(1,3) :\"+  \n                        s1.substring(1,3) );  \n    System.out.println(\"s1.indexOf('d') :\"+  \n                        s1.indexOf('d') );  \n    System.out.println(\" \\nInlocuire s1.replace('A','a') -> \\\"\"+ \ns1.replace('A','a') +\" \\\"\"); \n    System.out.println(\"s1=s1.toUpperCase() : \"+  \n                       (s1=s1.toUpperCase()) );  \n// comparatii  \n    String s2=\"ABCDEFGH\";",
    "place('A','a') -> \\\"\"+ \ns1.replace('A','a') +\" \\\"\"); \n    System.out.println(\"s1=s1.toUpperCase() : \"+  \n                       (s1=s1.toUpperCase()) );  \n// comparatii  \n    String s2=\"ABCDEFGH\";  \n    System.out.println(\" \\nString s1= \\\"\"+ s1+\", s2= \\\"\"+s2+\"\\\"\" ); \n    System.out.println(\"Comparatii: \\ns1==s2 :\"+(s1==s2));  \n    System.out.println(\"s1.equals(s2) :\"+ s1.equals(s2));  \n    System.out. println(\"s1.compareTo(s2) :\"+  \n                        s1.compareTo(s2) );  \n    System.out.println(\"s1.equalsIgnoreCase(s2) :\"+  \n                        s1.equalsIgnoreCase(s2) );  \n    System.out.println(\"Comparatii: \\ns1==so :\"+ (s1==so) + \"( so= \\\"\"+so+\"\\\" \n)\" ); \n// referinta  \n    String sx=s1;  \n    System.out.println(\" \\nComparatii referinta: \\ns1==sx :\"+ (s1==sx) );  \n    System.out.println(\"s1.equals(sx) :\"+ s1.equals(sx));  \n  } \n} \n \nProgramul produce urmatoarea iesire.  \n \nString s1=\"ABCdefgh\", so=s1  \ns1.length :8  \ns1.charAt(1) :B  \ns1.substring(1,3) :BC  \ns1.indexOf('d')",
    "t.println(\"s1.equals(sx) :\"+ s1.equals(sx));  \n  } \n} \n \nProgramul produce urmatoarea iesire.  \n \nString s1=\"ABCdefgh\", so=s1  \ns1.length :8  \ns1.charAt(1) :B  \ns1.substring(1,3) :BC  \ns1.indexOf('d') :3  \n \nInlocuire s1.replace('A','a') -> \"aBCdefgh\"  \ns1=s1.toUpperCase() : ABCDEFGH  \n \nString s1=\"ABCDEFGH, s2=\"ABCDEFGH\"  \nComparatii:  \ns1==s2 :false  \ns1.equals(s2) :true  \ns1.compareTo(s2) :0  \ns1.equalsIgnoreCase(s 2) :true  \nComparatii:  \ns1==so :false( so=\"ABCdefgh\" )  \n \nComparatii referinta:  \ns1==sx :true  \ns1.equals(sx) :true  \n \n \nSe observă că s1==s2  are valoarea false , deoarece reprezintă referinţe distincte, în schimb \ns1.equals(s2)  este true  deoarece conţinutul este identic.  \nMai trebuie observat şi că după atribuirea  \ns1=s1.toUpperCase()  \n \nreferinţa s1 pierde vechea valoare (memorată în so) către obiectul şir iniţial (\"ABCdefgh\") \nprimind valoarea referinţei unui nou şir obţinut din cel iniţial  prin transformarea tuturor literelor în \nmajuscule.",
    "s1 pierde vechea valoare (memorată în so) către obiectul şir iniţial (\"ABCdefgh\") \nprimind valoarea referinţei unui nou şir obţinut din cel iniţial  prin transformarea tuturor literelor în \nmajuscule. \nÎn clasa String  mai şi există metodele  toCharArray() , getChars()  şi getBytes()  care \ntransformă un şir într -un tablou de caractere, respectiv octeţi.  \n \nClasa StringBuffer  \n \nPrincipalele metode definitorii pentru această clasă şi care nu se regăsesc în clasa String  sunt \nurmătoarele  \n- s1.append(s2) – s2 este adăugat la s1; există mai mult e supradefiniri ale funcţiei pentru \nObject, String, char[]  (în cazul lui  char[] se precizează offset şi lungime), \nboolean, char, int, long, float, double )  \n- s.insert(i,valoare) – începând cu indicele i se inserează  în şirul s valoare( care \npoate fi Object, String, char[], boolean, char, int, long, float, \ndouble)  \n- s.reverse() – inversează ordinea  \n- s.setCharAt(i,c)  – stabileşte caracterul aflat la indicele i în şirul s ca fiin",
    "re \npoate fi Object, String, char[], boolean, char, int, long, float, \ndouble)  \n- s.reverse() – inversează ordinea  \n- s.setCharAt(i,c)  – stabileşte caracterul aflat la indicele i în şirul s ca fiind c \nExemplu cu clasa StringBuffer  \n \nclass sirbuf {  \n  public static void main(String [] args)  \n  { \n    StringBuffer s=new StringBuffer();  \n    StringBuffer s1=new StringBuffer(\"Caci unde -ajunge nu -i hotar, -\n\\tNici\");  \n    String s2=\" \\n\\tDin goluri a se naste.\";  \n \n    s1.setCharAt(28 , ' \\n');  // unde este ' -' \n    s1.append(\" ochi spre a cunoaste, \\n \"); \n    System.out.println(\"StringBuffer s1= \\n\\\"\"+ s1 +\" \\\"\"); \n \n    // adaugare la un sir vid     \n    s.append(s1).append(\"Si vremea -ncearca in zadar, \").append(s2);  \n    System.out.println(\" \\nStringBuffer s= \\n\\\"\"+ s +\" \\\"\"); \n \n    StringBuffer c= new StringBuffer(\"c= km/s\");  \n    c.insert(2, 300000.);  \n    System.out.println(\" \\nViteza luminii incidente : \\\"\"+ c +\" \\\"\"); \n    c.reverse();  \n    System.out.println(",
    "\"); \n \n    StringBuffer c= new StringBuffer(\"c= km/s\");  \n    c.insert(2, 300000.);  \n    System.out.println(\" \\nViteza luminii incidente : \\\"\"+ c +\" \\\"\"); \n    c.reverse();  \n    System.out.println(  \"Viteza luminii reflectate: \\\"\"+ c +\" \\\"\"); \n \n \n } \n} \n \n \n \n \n \nIn urma executiei programul produce iesirea urmatoare:  \n \nStringBuffer s1=  \n\"Caci unde -ajunge nu -i hotar,  \n        Nici ochi spre a cunoaste,  \n \" \n \nStringBuffer s=  \n\"Caci unde -ajunge nu -i hotar,  \n        Nici ochi spre a cunoaste,  \n Si vremea -ncearca in zadar,  \n        Din goluri a se naste.\"  \n \nViteza luminii incidente : \"c=300000.0 km/s\"  \nViteza luminii reflectate: \"s/mk 0.000003=c\"  \n \nClasa StringBuilder  \n \nEste compatibila cu clasa  StringBuffer dar fara garantii de siguranta in aplicatii concurente.  \nCompararea obiectelor  \nClasa Object  are metodele  : \nclone, equals , finalize , getClass , hashCode , notify, notifyAll , \ntoString , wait, wait, wait  \nMetoda equals()  din Object  compara referintele",
    "pararea obiectelor  \nClasa Object  are metodele  : \nclone, equals , finalize , getClass , hashCode , notify, notifyAll , \ntoString , wait, wait, wait  \nMetoda equals()  din Object  compara referintele. Daca se doreste mai mult trebuie rescrisa.  \npublic boolean equals(Object o) {  \n   if(o==null)  \nreturn false; \n   if(o==this)  \nreturn true; \n   if(!(o instanceof P unct)) \nreturn false; \n   Punct p = (P unct)o; \n   return x==p.x && y==p.y;  \n} \n \n \nEXEMPLU COMPLET (discutat la curs, pe baza sugestiilor si intrebarilor studentilor)  \n \n \npackage lab.comparpuncte;  \n \n/** \n * @author Pentiuc_St_Gh  + anul IIIC, oct.2019  \n */ \npublic class Punct {  \n    private int x,y;  \n \n    public Punct(int x, int y) {  \n        this.x = x;  \n        this.y = y;  \n    } \n \n    @Override  \n    public String toString() {  \n        return \"(\" + x + \", \" + y + '}';  \n    } \n \n    public Punct set X(int x) { // special pt.",
    "this.x = x;  \n        this.y = y;  \n    } \n \n    @Override  \n    public String toString() {  \n        return \"(\" + x + \", \" + y + '}';  \n    } \n \n    public Punct set X(int x) { // special pt. exercitiu  \n        this.x = x;  \n        return this;  \n    } \n    @Override  \n    public boolean equals(Object o) {  \n        if(o==null)  \n            return false;  \n        if(o==this)  \n            return true;  \n        if(!(o instanceof Punct))  \n            return false;  \n        Punct p = (Punct)o;  \n        return x==p.x && y==p.y;  \n   } \n \n} \n \npackage lab.comparpuncte;  \npublic class DemoComparPuncte {  \n    public static void main (String[] a){  \n        Punct   p=new Punct(1,2),  \n            q=new Punct(1,2),  \n            z = new Punct( -10,2); \n        System.out.println((p==q)+\" \"+ p.equals(q));  \n        System.out.println(q.equals(z.setX(1))   +\" \"+ \n                           p.equals(p.setX(20)));  \n        System.out.println(\"p=\"+p+\"  q=\"+q+\"  z=\"+z);  \n    } \n}",
    "p==q)+\" \"+ p.equals(q));  \n        System.out.println(q.equals(z.setX(1))   +\" \"+ \n                           p.equals(p.setX(20)));  \n        System.out.println(\"p=\"+p+\"  q=\"+q+\"  z=\"+z);  \n    } \n} \n \n \nRezultatul executiei:  \n \nfalse true  \ntrue true  \np=(20, 2}  q=(1, 2}  z=(1, 2}  \n \nExplicati  ! \n \n \nCompararea obiectelor potrivit unei relatii de ordine  este posibilă prin implementarea \nuneia din interfeţele  \n• java.lang.Comparable   \n• java.util.Comparator  \nInterfaţa java.util.Comparator   \n \npublic interface Comparator <T> { \n    public int compare(T o1,  T o2); \n} \n \n \nIn versiunile mai vechi  (formatul brut)  : \n \npublic interface Comparator  { \n    public int compare(Object o1,  Object o2);  \n} \n \nMetode care accepta obiecte Comparator ca argument  \n \nArrays.binarySearch( Object []  tablou, Object val, Comparator \ncompar) \nArrays.sort( Object [] tablou, Comparator compar) \n \nCollections.binarySearch( List lista, Comparator compar) \nCollections.max( Collection  colectie ,",
    "ect []  tablou, Object val, Comparator \ncompar) \nArrays.sort( Object [] tablou, Comparator compar) \n \nCollections.binarySearch( List lista, Comparator compar) \nCollections.max( Collection  colectie , Comparator compar) \nCollections.min( Collection  colectie , Comparator compar) \nCollections.sort( List lista, Comparator compar) \n \n \n \nExemplu  format brut ( versiuni anterioare ) \nimport java.util.Comparator;  \n \npublic class ComparatieSiruri implements Comparator { \n \n  public int compare(Object x, Object y) {  \n    String s1 = (String)x;  \n    String s2 = (String)y ; \n    return s1.toLowerCase(). compareTo(s2.toLowerCase()) ; \n  } \n} \n \nExemplu Java 8  \nimport java.util.Comparator;  \n \nclass ComparatieSiruri implements Comparator<String> { \n  @Override  \n  public int compare(String s1, String s2) {  \n    return s1.toLowerCase().compareTo(s2.toLowerCase());  \n  } \n} \n \nclass Aplicatie {  \n//...",
    "ratieSiruri implements Comparator<String> { \n  @Override  \n  public int compare(String s1, String s2) {  \n    return s1.toLowerCase().compareTo(s2.toLowerCase());  \n  } \n} \n \nclass Aplicatie {  \n//... \n \nString nume[]=               \n             {\"Maria\",\"Paula\",\"Ste fan\",\"Ioana\",\"George\",\"Alina\"};  \nArrays.sort(nume, new ComparatieSiruri() ); \nfor(String  s: nume)  \n    System.out.print(s+\" \");  \n//... \n} \n \n \nInterfaţa java.lang.Comparable   \n \n \npublic interface Comparable<T> {  \n   int compareTo( T o) ; \n} \n \n \nVersiuni anterioare, formatul brut:  \npublic interface Comparable  { \n   int compareTo( Object obj) ; \n} \n \nEste necesară atunci când se doreşte implementarea unei relaţii de ordine naturală  peste mulţimea \nobiectelor unei clase. Ob iectele claselor care implementează această interfaţă pot fi sortate fără a se \ndefini un alt comparator (elementele din List  cu Collection.sort , din Arrays  cu \nArrays.sort ).",
    "ctelor unei clase. Ob iectele claselor care implementează această interfaţă pot fi sortate fără a se \ndefini un alt comparator (elementele din List  cu Collection.sort , din Arrays  cu \nArrays.sort ). Obiectele unei astfel de clase pot constitui elementele unui obiect al unei clase ce \nimplementează SortedSet  sau cheile pentru o clasă ce implementează SortedMap . \n \nInterfaţa Comparable  conţine o singură metodă   \n \npublic int compareTo (T o) \n  \nAceastă metodă trebuie să compare obiectul curent cu cel specificat prin argument şi să returnrze un \nîntreg negativ dacă obiectul curent este mai mic, zero dacă sunt egale sau un întreg pozitiv dacă \nobiectul curent este mai mare. Metoda care va implementa comparaţia trebuie să respecte axiomele de \ndefiniţie ale relaţiei de ordine.icare ar fi obiectele x şi y valoarea returnată de x.compareTo(y)  \ntrebuie să fie de semn contrar valorii returnate de y.compareTo(x) .",
    "ebuie să respecte axiomele de \ndefiniţie ale relaţiei de ordine.icare ar fi obiectele x şi y valoarea returnată de x.compareTo(y)  \ntrebuie să fie de semn contrar valorii returnate de y.compareTo(x) .  \n2. Metoda implementată trebuie să fie tranzitivă:  \n x.compareTo(y)>0 && y.compareTo(z)>0)  implică x.compareTo(z)>0 .  \n3. Dacă x.compareTo(y)==0  atunci oricare ar fi z semnul valorii returnate de x.compareTo(z) \neste acelaşi cu semnul valorii returnate de y.compareTo(z) .  \nEste recomandat imperativ  ca metoda compareTo()  implementată să fie consistentă cu metoda \nequals()  utilizată  \n(x.compareTo(y)==0) == (x.equals(y)) , oricare ar fi x şi y  \nDacă nu se respectă această recomandare, acest lucru trebuie notificat utilizatorilor ei  (exemplu: \n“această clas ă posedă o ordine naturală care nu este consistentă cu equals”).  \nExcepţia ClassCastException  este lansată atunci când obiectul din argument nu poate fi comparat cu \nobiectul curent.",
    "“această clas ă posedă o ordine naturală care nu este consistentă cu equals”).  \nExcepţia ClassCastException  este lansată atunci când obiectul din argument nu poate fi comparat cu \nobiectul curent.  \nExcepţia NullPointerException   este lansată atunci când argumentul este null (metoda equals pentru \nargument null , ob.equals(null), nu lansează nicio excepţie ci retur nează  false ). \n \n \nExemplu  \n \npackage comparatii;  \nimport java.util.*;  \n \npublic class Stud2Note implements Comparable<Stud2Note> {  \n  private int notaSD, notaJava;  \n \n  public Stud2Note(int n1,int n2) {  \n     notaSD   = n1;  \n     notaJava = n2;  \n  } \n  public int getNotaSD() {  \n     return notaSD;  \n  } \n \n  @Override  \n  public int compareTo(Stud2Note x) {  \n    if(x==null) return 1;  \n    if(equals(x)) return 0;  \n    float media1 = (notaSD + notaJava) /2,  \n          media2 = (x.notaSD + x.notaJava)/2;  \n    return media1 < media2 ?",
    "eTo(Stud2Note x) {  \n    if(x==null) return 1;  \n    if(equals(x)) return 0;  \n    float media1 = (notaSD + notaJava) /2,  \n          media2 = (x.notaSD + x.notaJava)/2;  \n    return media1 < media2 ? -1 : 1; \n  } \n \n  @Override  \n  public boolean equals(Object x) {  \n    return  \n      x!=null \n      && (x instanceof Stud2Note)  \n      && (notaSD == ((Stud2Note)x).notaSD)  \n      && (notaJava == ((Stud2Note)x).notaJava);  \n  } \n \n  @Override  \n  public String toString() {  \n     return \"(SD =\" + notaSD + \" notaJava =\" +notaJava+\")\";  \n  } \n \n     \n@Override  \n    public int hashCode() {  \n        int hash = 5;  \n        hash += 37 * hash + this.notaSD;  \n        hash += 41 * hash + this.notaJava;  \n        return hash;  \n    } \n \n  public static void main(String args[])  \n  { \n      Stud2Note e=new Stud2Note(9,5),  \n              f=new Stud2Note(7,10),  \n              g=new Stud2Note(9,5),  \n              t[]= new Stud2Note[]{e,f,g},  \n              p[]=t; \n \n      System.out.println(",
    "Note e=new Stud2Note(9,5),  \n              f=new Stud2Note(7,10),  \n              g=new Stud2Note(9,5),  \n              t[]= new Stud2Note[]{e,f,g},  \n              p[]=t; \n \n      System.out.println(\"e: \"+e+\" \\nf: \"+f+\" \\ng: \"+g);  \n      System.out.println(\"e.compareTo(f)=\"+e.compareTo(f));  \n      System.out.println(\"e.compareTo(g)=\"+e.compareTo(g));  \n      System.out.println(\"f.compareTo(g)=\"+f.compareTo(g));  \n      System.out.println(\"t=\"+t[0]+\" \"+t[1]+\" \"+t[2]);  \n      Arrays.sort(t);  \n      System.out.println(\"Dupa sort(t)=\"+t[0]+\" \"+t[1]+\" \"+t[2]);  \n      System.out.println(\"p=\"+p[0]+\" \"+p[1]+\" \"+p[2]) ; \n      Arrays.sort(p, new Comparatie() ); \n      System.out.println(\"Dupa sort(p,new Comparatie())=\"+  \n                                  p[0]+\" \"+p[1]+\" \"+p[2]);  \n  } \n} \n// \n// Acest comparator realizeaza comparatia a doi Stud2Notei  \n// doar pe baza notei de la SD \n// \nclass Comparatie implements Comparator<Stud2Note> {  \n   @Override  \n   public int compare(Stud2Note",
    "// Acest comparator realizeaza comparatia a doi Stud2Notei  \n// doar pe baza notei de la SD \n// \nclass Comparatie implements Comparator<Stud2Note> {  \n   @Override  \n   public int compare(Stud2Note a, Stud2Note b)  \n   { \n      int n1 = a.getNotaSD(),  \n          n2 = b.getNotaSD();  \n      return (n1 < n2 ? -1 : (n1 == n2 ? 0 : 1));  \n   }   \n   /*   public int compare(Object a, Object b) { \n      int n1=((Stud2Note)a).getNotaSD(),  \n          n2=((Stud2Note)b).getNotaSD();  \n      return (n1 < n2 ? -1 : (n1 == n2 ? 0 : 1));  \n   } \n   */ \n} \n \n \n \n \n \n \nRezultatul execu ţíei  \n \nC:\\pg\\sd\\Curs8>java Stud2Note  \ne: (SD =9 Java =5)  \nf: (SD =7 Java =10)  \ng: (SD =9 Java =5)  \ne.compareTo(f)= -1 \ne.compareTo(g)=0  \nf.compareTo(g)=1  \nt=(SD =9 Java =5) (SD =7 Java =10) (SD =9 Java =5)  \nDupa sort(t)=(SD =9 Java =5) (SD =9 Java =5) (SD =7 Java =10)  \np=(SD =9 Java =5) (SD =9 Java =5) (SD =7 Java =10)  \nDupa sort(p,new Comparatie())=  \n                       (SD =7 Java =10) (SD =9 Java =",
    "a sort(t)=(SD =9 Java =5) (SD =9 Java =5) (SD =7 Java =10)  \np=(SD =9 Java =5) (SD =9 Java =5) (SD =7 Java =10)  \nDupa sort(p,new Comparatie())=  \n                       (SD =7 Java =10) (SD =9 Java =5) (SD =9 \nJava =5)  \n \nIntrebari  \n1. Ce se intampla daca la apelul metodelor compare()  si compareTo()  argumentele efective nu sunt de tip \nStud2Note  ? \n2. Ce s-ar afisa daca la sfarsitul metodei main()  s-ar adauga   \nSystem.out.println(\"t=\"+t[0]+\" \"+t[1]+\" \"+t[2]);  System.out.println( t); ? \nClasa Arrays  \n \nAceasta clasa din pachetul java.util contine metode statice de prelucrare a tablourilor.  \nDocumentatia o gasiti la adresa https://docs.oracle.com/javase/7/docs/a pi/java/util/Arrays.html  \n \nCateva metode utile  sunt prezentate in tabelul urmator.  \nNota.  In tabelul s -au folosit notatiile  : \n• array - poate fi  un tablou de tipuri primitive (short[], int[], …, double[]) sau un tablou de \nobiecte (Object[], T[]),  \n• value - o val oare de acelasi tip cu elementele tabloului.",
    "notatiile  : \n• array - poate fi  un tablou de tipuri primitive (short[], int[], …, double[]) sau un tablou de \nobiecte (Object[], T[]),  \n• value - o val oare de acelasi tip cu elementele tabloului.  \n \nMetoda  Descriere  \nbinarySearch( array , value ) Cauta in tabloul  array  valoarea , value . Daca \nvaloarea e in tablou  se intoarce indicele elemntului de \ntablou care o contine, altfel se intoarce <0  \nbinarySearch( array , fromIndex, toIndex, \nvalue ) Se cauta de la indicele from  (inclusiv) la indicele to \n(exclusiv)  \nbinarySearch( T[] a , int fromIndex, int \ntoIndex, T key , Comparator<? super T> c)  Cautarea utilizeaza comparatorul c \ncopyOf( array , length ) Returneaza o copie a tabloului, noua lungime fiind \nlength , daca e mai mare decat lungimea initiala se \ncompleteaza cu null \ncopyOfRange(T[] original, int from, int to)  Se copiaza d e la indicele from  (iclusiv) la indicele to \n(exclusiv)  \nequals( array1 , array2 ) Returneaza true daca ambele tablouri au aceleasi \nelem",
    "l \ncopyOfRange(T[] original, int from, int to)  Se copiaza d e la indicele from  (iclusiv) la indicele to \n(exclusiv)  \nequals( array1 , array2 ) Returneaza true daca ambele tablouri au aceleasi \nelemente in aceeasi ordine  \nfill(array , value ) Se initializeaza elementele din array  cu value  \nfill(Object[] a, int fromIndex, int toIndex, \nObject val)  Se initializeaza elementeel din a de la indicele from \n(iclusiv) la indicele to (exclusiv)  \nsort(array ) Se sorteaza elementele din array . Daca array  este \nun tablou de obiecte atunci pentru sortare se utilizeaza \nordinea naturala (obiectele trebuie sa apartina unei \nclase care implementeaza interfata \njava.lang.Comparable, adica au definita metoda \ncompareTo())  \nsort(Object[] a, int fromIndex, int toIndex)  Se sorteaza incepand cu fromIndex inclusiv, pana la \ntoIndex exclusiv .Oobiectele din tabloul a trebuie sa \napartina unei clase care implementeaza interfata \njava.lang.Compara ble \nsort(T[] a, Comparator<?",
    "rteaza incepand cu fromIndex inclusiv, pana la \ntoIndex exclusiv .Oobiectele din tabloul a trebuie sa \napartina unei clase care implementeaza interfata \njava.lang.Compara ble \nsort(T[] a, Comparator<? super T> c)  Se utilizeaza comparatorul c pentru sortar e \nsort(T[] a, int fromIndex, int toIndex,  \n                      Comparator<? super T> c)  Se sorteaza incepand cu fromIndex inclusiv, pana la \ntoIndex exclusiv . Se utilizeaza comparatorul c pentru \nsortare  \ntoString( array ) Converteste tabloul intr -un sir utilizand metoda \ntoString() a fiecarui elment din tablou; exemplu[12, ‚’ \nabc’ 3,14]  \n \n \nClase anonime  \n \nClasele anonime sunt clase fara nume, interioare care dat fiind ca sunt anonime nu pot fi instantiate \ndecat o singura data.  \n \nabstract  class Student  { \n    String nume;  \n    public Student(String nume) {  \n        this.nume = nume;  \n    } \n    abstract void studiaza();  \n \n} \npublic class TestClasaAnonima  { \n \n   public static void main(String[] args) {",
    "me;  \n    public Student(String nume) {  \n        this.nume = nume;  \n    } \n    abstract void studiaza();  \n \n} \npublic class TestClasaAnonima  { \n \n   public static void main(String[] args) {  \n         \n      Student s = new Student (\"Ionescu\"){  \n         void studiaza(){  \n             System.out.println(nume +  \n                   \" a terminat tema la SDA\");  \n         } \n      };     \n      s.studiaza();  \n  }  \n} \n \nIn acest caz clasa anonima a fost o extindere a clasei abstracte Student prin implementarea metodei \nabstracte studiaza().  Secventa marcata cu violet executa doua lucruri:  \n• defineste o clasa anonima care extinde clasa Student   \n• creeaza o instanta a acestei clase anonime  \nIesirea produsa este urmatoarea:  \nIonescu a terminat tema la SDA  \nPutem avea si 2 sau mai multe implementari anonime ale aceleeasi clase abstracte  \npublic class TestClasaAnonima {  \n    public static void main(String[] args) {  \n         \n        Student stud1 = new Student (\"Ionescu\"){",
    "multe implementari anonime ale aceleeasi clase abstracte  \npublic class TestClasaAnonima {  \n    public static void main(String[] args) {  \n         \n        Student stud1 = new Student (\"Ionescu\"){  \n            void studiaza(){  \n                System.out.println(nume + \" a terminat tema la SDA\");  \n            } \n        };     \n \n        Student stud2 = new Student (\"Vasilescu\"){  \n            void studiaza(){  \n                System.out.println(nume + \" a co nfigurat un Access Point\");  \n            } \n        };     \n \n        stud1.studiaza();  \n        stud2.studiaza();  \n   } \n} \n \nIesirea produsa este urmatoarea:  \nIonescu a terminat tema la SDA  \nVasilescu a configurat un Access Point  \n \nPutem avea clase anonime interioare care sa extinda  in acelasi mod o  clasa parinte.  \n \nClase interioare anonime care  implement eaza o  interf ata \n \nFie interfata Voluntar  \n \npublic interface Voluntar {  \n    public void actiune();  \n} \n \nIn clasa de mai jos se defineste o clasa inte",
    "Clase interioare anonime care  implement eaza o  interf ata \n \nFie interfata Voluntar  \n \npublic interface Voluntar {  \n    public void actiune();  \n} \n \nIn clasa de mai jos se defineste o clasa interioara anonima care implementeaza interfata  si creeaza un \nobiect din aceasta clasa anonima.  \n \npublic class TestClasaAnonima2 {  \n  \n  public static void main(String[] args) {  \n \n   Voluntar v = new Voluntar(){  \n        @Override  \n        public void actiune() {  \n            System.out.println(\"Tutoriat cu studentii din ani mai mici\");  \n        } \n         \n    }; \n    v.actiune();  \n  } \n} \n \nPentru mai multe informatii accesati \nhttps://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html  \n \nClase anonime utilizate ca si comparatori  \n \nUtilizarea comparatorilor si a claselor anonmie va fi prezentata printr -un exemplu care utilizeaza \nsortarea bazata pe ordinea naturala sau cu  un comparator.",
    "anonime utilizate ca si comparatori  \n \nUtilizarea comparatorilor si a claselor anonmie va fi prezentata printr -un exemplu care utilizeaza \nsortarea bazata pe ordinea naturala sau cu  un comparator. Acesta poate fi o instanta a unei  clase externe  \n(ca in exemplul precedent cu Stud2Note ) sau o instanta a unei clase anonime ca in exemplul  de mai jos  \nin care constructorul clasei anonime este marcat cu   galben . \nAplicatia din exemplu este compusa din trei clase : ParcAuto (main), Autovehicul si \nComparNumarInmatriculare care implementeaza inte rfetele comparable si Comparator din java,util si \nutilizeaza clase anonime cionstruite cu interfata Comparator.  \n \n \nNota.  Referitor la interf ata java.util.Comparator  se reaminteste faptul ca intr-o interfata Java \npot exista metode abstracte, dar si metode concrete, declarate cu default , care constituie o \nimplementare implicita si pot fi utilizate in clasele care implementeaza interfata  sau optional \nsuprascrise  daca se doreste ac",
    "cte, dar si metode concrete, declarate cu default , care constituie o \nimplementare implicita si pot fi utilizate in clasele care implementeaza interfata  sau optional \nsuprascrise  daca se doreste acest lucru . \n \nClasa Autovehicul  \n \nPentru a demonstra cât mai multe posibilități de realizare a comparației obiectelor în această clasă sunt \ndoi comparatori  \n- comparatorul care realizează ordinea naturală (după tipul motorului: C(onventional), E(lectric), \nH(ibrid)) și implementează interfața Comparable<Autovehicul>  \n \npublic int compareTo (Autovehicul  o) \n- un obiect comparator realiza t cu o clasă anonimă care extinde  clasa Comparator <Autovehicul >. \nAcest obiect comparator are referința memorată în variabila statică  comparPutere  și prin modul în \ncare este scris determină sortarea în ordine descrescătoare , după valoarea câmpului putere din \nfiecare obiect de tip Autovehicul . \n \n \npackage ro.usv; \nimport java.util.Comparator ; \nimport java.util.Objects ; \n\n \npublic class Aut",
    "a în ordine descrescătoare , după valoarea câmpului putere din \nfiecare obiect de tip Autovehicul . \n \n \npackage ro.usv; \nimport java.util.Comparator ; \nimport java.util.Objects ; \n\n \npublic class Autovehicul implements Comparable <Autovehicul > { \n    private String marca=\"?\"; \n    private String nr=\"?\"; \n    private int putere=0; \n    private String tipMotor =\"?\"; \n \n    public Autovehicul (String marca, String nr, int putere, String tipMotor) {  \n        if(marca!= null) \n            this.marca = marca;  \n        if(nr!=null) \n            this.nr = nr; \n        if(tipMotor!= null) \n            this.tipMotor = tipMotor;  \n        if(putere> 0) \n            this.putere = putere;  \n    } \n \n    public static Comparator <Autovehicul > comparPutere = new Comparator <>() { \n        @Override  \n        public int compare(Autovehicul o1, Autovehicul o2) { \n           if (o1.getPutere() < o2.getPutere())  \n                return -1; \n            else \n                return o1.getPutere() ==",
    "public int compare(Autovehicul o1, Autovehicul o2) { \n           if (o1.getPutere() < o2.getPutere())  \n                return -1; \n            else \n                return o1.getPutere() == o2.getPutere() ? 0 : 1; \n        } \n    }; \n \n    @Override  \n    //această clasă posedă o ordine naturală care nu este consistentă cu equals  \n    public int compareTo (Autovehicul o) { \n        return tipMotor .compareToIgnoreCase(o. tipMotor ); \n    } \n \n@Override  \npublic boolean equals(Object o) { \n    if (this == o) return true ; \n    if (o == null || getClass() != o.getClass()) return false ; \n    Autovehicul that = (Autovehicul ) o; \n    return putere == that.putere && \n            marca.equals( that.marca) && \n            nr.equals( that.nr) && \n            tipMotor .equals( that.tipMotor ); \n} \n \n@Override  \npublic int hashCode () { \n    return Objects.hash(marca, nr, putere, tipMotor ); \n} \n \n    @Override  \n    public String toString () { \n        return \"{\" + marca + \", \" + n",
    "Motor ); \n} \n \n@Override  \npublic int hashCode () { \n    return Objects.hash(marca, nr, putere, tipMotor ); \n} \n \n    @Override  \n    public String toString () { \n        return \"{\" + marca + \", \" + nr + \n                \", putere=\" + putere + \n                \", tipMotor='\" + tipMotor + '\\'' + \n                '}'; \n    } \n \n    public String getMarca () { \n        return marca; \n    } \n \n    public String getNr() { \n        return nr; \n    } \n \n    public int getPutere () { \n        return putere; \n    } \n \n    public String getTipMotor () { \n        return tipMotor ; \n    } \n} \n \nObservatii  \n1) Cei doi comparatori din clasa Autovehicul  sunt utilizați în metoda main() din clasa ParcAuto . \na) Comparatorul de ordine naturală (prin implementarea interfaței Comparable ) \n \n        System.out.println( \"\\nSortare dupa tipul motorului\" ); \n        Arrays.sort(p.masini, 0, p.nrMasini ); \n        System.out.println( Arrays.toString (p.masini)); \n \nb) Comparatorul realizat prin extinderea i",
    "out.println( \"\\nSortare dupa tipul motorului\" ); \n        Arrays.sort(p.masini, 0, p.nrMasini ); \n        System.out.println( Arrays.toString (p.masini)); \n \nb) Comparatorul realizat prin extinderea interfetei  Comparator ; se reamintește că referința \ncătre acest obiect comparator este memorată în variabila statică Autovehicul .comparPutere  \n \nUtilizarea acestor doi comparatori este in secventa urmatoare:  \n \n        System.out.println( \"\\nSortare dupa putere (crescator)\" ); \n        Arrays.sort(p.masini, 0, p.nrMasini , Autovehicul .comparPutere ); \n        System.out.println( Arrays.toString (p.masini)); \n \n        System.out.println( \"\\nSortare dupa putere ( descrescator)\" ); \n        Arrays.sort(p.masini,0,p.nrMasini , Autovehicul .comparPutere .reversed());  \n        System.out.println( Arrays.toString (p.masini)); \n \nSe va observa ca pentru sortarea descrescatoare s -a utilizat un obiect  comparator care sa permita \nobtinerea acestui mod de sortare prin aplicarea metodei revers",
    "tln( Arrays.toString (p.masini)); \n \nSe va observa ca pentru sortarea descrescatoare s -a utilizat un obiect  comparator care sa permita \nobtinerea acestui mod de sortare prin aplicarea metodei reversed()  din Comparator  (metoda default  in \ninterfata)  \nAutovehicul .comparPutere .reversed()  \n \n2) Metodele equa ls() si hashCode() au fost generate automat; pentru metoda equals() s -a indcat ca \nvalorile campurilor clasei sunt non null; de caeea au fost initializate cu “?” si inconstructor s -au pus \nvalidari pentru a nu permite crearea de obiecte cu null pentru numele marcii, tip motor sau nr. \ninmatriculare  \n3) Clasa Autovehicul  are o ordine naturala bazata numai pe tipul motorului, in timp ce equals()  \nverifica egalitatea tuturor celor 4 campuri ; de aceea s -a indica ca aceasta clasa are o ordine naturala \ncare nu este consistenta cu equals() . \n \n \nClasa exterioară ComparNrInmatriculare  \n \nIlustreaza o alta posibilitate de a crea un comparator printr -o clasa speciala care sa",
    "a are o ordine naturala \ncare nu este consistenta cu equals() . \n \n \nClasa exterioară ComparNrInmatriculare  \n \nIlustreaza o alta posibilitate de a crea un comparator printr -o clasa speciala care sa implementeze \ninterfata Comparator<T>.  \nComparatorul implementat aici face ca algoritmul de sortare sa ‘impinga’ toate valorile null din vector \ncatre indicii mai mari (catre la sfarsitul vectorului)  \n \npackage ro.usv; \n \nimport java.util.Comparator ; \n \npublic class ComparNrInmatriculare implements Comparator <Autovehicul > { \n    @Override  \n    // pentru sortarea tablourilor care contin null acestea vor apare la sfarsit  \n    public int compare(final Autovehicul masina1, final Autovehicul masina2) {  \n        if (masina1==masina2) return 0; \n        if (masina1== null) return 1;   // pentru ca sort() sa mute null la urma  \n        if (masina2== null) return -1;  // idem \n        return masina1.getNr().compareToIgnoreCase(masina2.getNr());  \n    } \n} \n \n \nApelul acestui c omparator est",
    "ru ca sort() sa mute null la urma  \n        if (masina2== null) return -1;  // idem \n        return masina1.getNr().compareToIgnoreCase(masina2.getNr());  \n    } \n} \n \n \nApelul acestui c omparator este in metoda main() din clasa ParcAuto  \nArrays.sort(masini, new ComparNrInmatriculare());  \n \nDeci fara a preciza indexul de inceput si sfarsit din tablou in care sort() executa sortarea.  \n \nClasa ParcAuto  \n \nEste o clasa care reprezinta o multime de masini implementata printr -un vector Autovehicul \nmasini[] . Metoda main()  afiseaza aceasta multime in diferite ordini posibile pentru a demonstra \ndiversitatea operatorilor folositi.  \nIn aceasta clasa sunt implementai  2 comparatori:  \n1) un Comparator care compara autovehiculele dupa marca prin implementarea unei clase \nanonime (marcat cu galben ) \n2) clasa ParcAuto implementeaza interfata Comparator <Autovehicul > si are un Comparator \ncare compara doua autovehicule cu ajutorul unu i punctaj Eco ce favorizeaza autovehiculele cu \nmotor",
    "alben ) \n2) clasa ParcAuto implementeaza interfata Comparator <Autovehicul > si are un Comparator \ncare compara doua autovehicule cu ajutorul unu i punctaj Eco ce favorizeaza autovehiculele cu \nmotor electric sau hybrid si pe cele cu putere mic a (marcat cu albastru ) si utilizat astfel       \n \nArrays.sort(p.masini, 0, p.nrMasini , p); \nUtilizarea acestui ultim comparator este realizata cu obiectul  de tip ParcAuto  referit de varabila p. \n \n \nClass ParcAuto  \n \npackage ro.usv; \n \nimport java.util.Arrays ; \nimport java.util.Comparator ; \n \npublic class ParcAuto implements Comparator <Autovehicul > { \n    private int nrMasini =0; \n    private Autovehicul [] masini = new Autovehicul[ nrMasini ]; \n \n    public String toStringParcAuto (boolean dupaNrInmatriculare)  \n    { \n        if(dupaNrInmatriculare)  \n           Arrays.sort(masini, new ComparNrInmatriculare());  \n        else \n           Arrays.sort(masini, 0, nrMasini , \n             new Comparator <Autovehicul >() {   // clasa anon",
    "matriculare)  \n           Arrays.sort(masini, new ComparNrInmatriculare());  \n        else \n           Arrays.sort(masini, 0, nrMasini , \n             new Comparator <Autovehicul >() {   // clasa anonima  \n               @Override  \n               public int compare(final Autovehicul m1, final Autovehicul m2) { \n                     return m1.getMarca().compareToIgnoreCase (m2.getMarca());  \n               } \n             } // sfarsit clasa anonima  \n        ); \n        return Arrays.toString (masini); \n    } \n \n    public void adaugaAutovehicul (Autovehicul x){ \n        if (nrMasini >=masini.length){ \n            masini = Arrays.copyOf(masini, nrMasini +10); \n        } \n        masini[nrMasini ++] = x;  \n    } \n \n    private static int punctajEco (Autovehicul a){ \n        switch(a.getTipMotor()){  \n            case \"E\": \n                return a.getPutere();  \n            case \"H\": \n                return 10000 + a.getPutere();  \n            case \"C\": \n                return 20000 + a",
    "otor()){  \n            case \"E\": \n                return a.getPutere();  \n            case \"H\": \n                return 10000 + a.getPutere();  \n            case \"C\": \n                return 20000 + a.getPutere();  \n            default: \n                return 30000; \n        } \n    } \n    @Override  \n    public int compare(Autovehicul o1, Autovehicul o2) { \n        int n1 = punctajEco (o1); \n        int n2 = punctajEco (o2); \n        return n1<n2 ? -1: (n1==n2?0:1); \n    } \n \n    public static void main(String[] a){ \n        ParcAuto p = new ParcAuto();  \n        p.adaugaAutovehicul( new Autovehicul( \"Logan\", \"NT-17-ADE\", 95, \"C\")); \n        p.adaugaAutovehicul( new Autovehicul( \"WW\", \"CJ-07-ABC\", 125, \"E\")); \n        p.adaugaAutovehicul( new Autovehicul( \"Logan\", \"SV-07-ABC\", 80, \"C\")); \n        p.adaugaAutovehicul( new Autovehicul( \"Opel\", \"BT-01-XYX\", 100, \"H\")); \n \n        System.out.println( \"\\nSortare dupa tipul motorului\" ); \n        Arrays.sort(p.masini, 0, p.nrMasini );",
    "p.adaugaAutovehicul( new Autovehicul( \"Opel\", \"BT-01-XYX\", 100, \"H\")); \n \n        System.out.println( \"\\nSortare dupa tipul motorului\" ); \n        Arrays.sort(p.masini, 0, p.nrMasini ); \n        System.out.println( Arrays.toString (p.masini)); \n \n        System.out.println( \"\\nSortare dupa putere (crescator)\" ); \n        Arrays.sort(p.masini, 0, p.nrMasini , Autovehicul .comparPutere ); \n        System.out.println( Arrays.toString (p.masini)); \n \n        System.out.println( \"\\nSortare dupa putere (descrescator)\" ); \n        Arrays.sort(p.masini,0,p.nrMasini , Autovehicul .comparPutere .reversed());  \n        System.out.println( Arrays.toString (p.masini)); \n \n        System.out.println( \"\\nSortare dupa marca\" ); \n        System.out.println( p.toStringParcAuto( false)); \n \n        System.out.println( \"\\nSortare dupa nr. inmatriculare\" ); \n        System.out.println( p.toStringParcAuto( true)); \n \n        System.out.println( \"\\nSortare dupa punctaj Eco\" ); \n        Arrays.sort(p",
    "System.out.println( \"\\nSortare dupa nr. inmatriculare\" ); \n        System.out.println( p.toStringParcAuto( true)); \n \n        System.out.println( \"\\nSortare dupa punctaj Eco\" ); \n        Arrays.sort(p.masini, 0, p.nrMasini , p); \n        System.out.println( Arrays.toString (p.masini)); \n    } \n} \n \nNota . In acest exemplu veti mai observa si alte utilizari ale clasei Arrays . \n1. Realizarea unei copii a tabloului  masini[]  atunci cand se depaseste capacitatea  \n \n private Autovehicul[] masini = new Autovehicul[10];  \n    private int nrMasini =0; \n \n    public void adaugaAutovehicul(Autovehicul x){  \n        if (nrMasini>=masini.length){  \n            masini = Arrays.copyOf(masini, nrMasini+10) ; \n        } \n        masini[nrMasini++] = x;  \n } \n \n2. Deoarece in tablou l  masini[]  exista valori null, in astfel de situatii exista 2 solutii de evitare \na exceptiei nullPointer  la sortare .",
    "0) ; \n        } \n        masini[nrMasini++] = x;  \n } \n \n2. Deoarece in tablou l  masini[]  exista valori null, in astfel de situatii exista 2 solutii de evitare \na exceptiei nullPointer  la sortare . \na) Daca numai primele elemente sunt diferite de null, iar restul sunt null (ca in ex. nostru unde \nprimele nrMasini  elemente sunt nenule), atunci se foloseste s ortarea doar a primelor \nelemente  (de la indicele 0 inclusiv la indicele nrMasini  exclusiv)  \n \nArrays.sort(masini, 0, nrMasini,  new Comparator<Autovehicul>() { …. } ); \n \nb) Daca valorile null sunt amestecate printre elementele nenule ale tabloului este necesara \nintroducerea de cod in comparator care sa verifice daca exista valori null si sa le ‚impinga’ \npe acestea spre sfarsi tul tabloului.  \n \n@Override  \npublic int compare (final Autovehicul masina1, final Autovehicul masina2)  \n{ \n        if (masina1==masina2) return 0;  \n        if (masina1==null) return 1;   // pentru ca sort() sa mute null la urma  \n        if (masi",
    "(final Autovehicul masina1, final Autovehicul masina2)  \n{ \n        if (masina1==masina2) return 0;  \n        if (masina1==null) return 1;   // pentru ca sort() sa mute null la urma  \n        if (masina2==null) return -1;  // idem \n        return  \n                 masina1.getNr().compareToIgnoreCase(masina2.getNr());  \n} \n \nOBSERVATIE  \nIn clasa ParcAuto  putea fi utilizata o lista pentru a stoca masinile firmei  si nu ar  mai fi fost \naceste probleme.  \n: \nimport java.util.ArrayList;  \nimport java.util.List;  \n// . . .  \n    private List masini = new ArrayList<Autovehicul>();  \n// . . .  \n \nList este interfata, iar ArrayList< T> este o clasa ce implementeaza interfata List. Avantajele  acestei \nsolutii  le vom prezenta ulterior.   \nS-a preferat sa se utilizeze tablouri ata t din moti ve legate de momentl prezentarii  cursului, dar si \ndatorita faptului ca utilizarea tablourilor are avantajul vitezei.",
    "le vom prezenta ulterior.   \nS-a preferat sa se utilizeze tablouri ata t din moti ve legate de momentl prezentarii  cursului, dar si \ndatorita faptului ca utilizarea tablourilor are avantajul vitezei.  \n \n3. Conversia la sir a tabloului  \nArrays.toString(masini);  \nIesirea produsa a fost urmatoarea:  \n \n \nSortare dupa tipul motorului  \n[{Logan, NT-17-ADE, putere=95, tipMotor='C'}, {Logan, SV -07-ABC, putere=80, \ntipMotor='C'}, {WW, CJ -07-ABC, putere=125, tipMotor='E'}, {Opel, BT -01-XYX, \nputere=100, tipMotor='H'}, null, null, null, null, null, null]  \n \nSortare dupa putere (crescator)  \n[{Logan, SV-07-ABC, putere=80, tipMotor='C'}, {Logan, NT -17-ADE, putere=95, \ntipMotor='C'}, {Opel, BT -01-XYX, putere=100, tipMotor='H'}, {WW, CJ -07-ABC, \nputere=125, tipMotor='E'}, null, null, null, null, null, null]  \n \nSortare dupa putere (descrescator)  \n[{WW, CJ -07-ABC, putere=125, tipMotor='E'}, {Opel, BT -01-XYX, putere=100, \ntipMotor='H'}, {Logan, NT -17-ADE, putere=95, tipMotor='C'}, {Loga",
    "ll, null, null]  \n \nSortare dupa putere (descrescator)  \n[{WW, CJ -07-ABC, putere=125, tipMotor='E'}, {Opel, BT -01-XYX, putere=100, \ntipMotor='H'}, {Logan, NT -17-ADE, putere=95, tipMotor='C'}, {Logan, SV -07-ABC, \nputere=80, tipMotor='C'}, null, null, null, null, null, null]  \n \nSortare dupa marca  \n[{Logan, NT -17-ADE, putere=95, tipM otor='C'}, {Logan, SV -07-ABC, putere=80, \ntipMotor='C'}, {Opel, BT -01-XYX, putere=100, tipMotor='H'}, {WW, CJ -07-ABC, \nputere=125, tipMotor='E'}, null, null, null, null, null, null]  \n \nSortare dupa nr. inmatriculare  \n[{Opel, BT -01-XYX, putere=100, tipMotor='H'} , {WW, CJ -07-ABC, putere=125, \ntipMotor='E'}, {Logan, NT -17-ADE, putere=95, tipMotor='C'}, {Logan, SV -07-ABC, \nputere=80, tipMotor='C'}, null, null, null, null, null, null]  \n \nSortare dupa punctaj Eco  \n[{WW, CJ -07-ABC, putere=125, tipMotor='E'}, {Opel, BT -01-XYX, putere=100, \ntipMotor='H'}, {Logan, SV -07-ABC, putere=80, tipMotor='C'}, {Logan, NT -17-ADE, \nputere=95, tipMotor='C'},",
    "punctaj Eco  \n[{WW, CJ -07-ABC, putere=125, tipMotor='E'}, {Opel, BT -01-XYX, putere=100, \ntipMotor='H'}, {Logan, SV -07-ABC, putere=80, tipMotor='C'}, {Logan, NT -17-ADE, \nputere=95, tipMotor='C'}, null, null, null, null, null, null]  \n \n \nDaca am fi utilizat  \nSystem.out.println(p);  \n \nIesirea produsa ar fi fost doar: ParcAuto@31befd9f  \nDaca utilizam System.out.println(Arrays.toString(p.masini));  tabloul  p.masini \neste afisat ca mai sus.  \n \nALTA OBSERVATIE  \n \nAtentie la metode publice care returneaza referinta catre un tablou sau un alt obiect. Exemplu  \n \nprivate Autovehicul [] masini = new Autovehicul[ nrMasini ]; \n \npublic Autovehicul [] getMasini () { \n    return masini; \n} \n \nDin exterior nu se poate modifica referinta catre vectorul masini [], insa continutul acestuia poate fi \nmdificat printr -o atribuire  \np.getMasini()[ 0]=null; \n Chiar daca se declara final masini nu se impiedica modifica rea ca m ai sus, deoarece declararea  \n \nprivate final Autovehicul [] masini =",
    "fi \nmdificat printr -o atribuire  \np.getMasini()[ 0]=null; \n Chiar daca se declara final masini nu se impiedica modifica rea ca m ai sus, deoarece declararea  \n \nprivate final Autovehicul [] masini = new Autovehicul[ nrMasini ];  //are implicatii  \n \nimpiedica doar modificarea referintei masini  nu si a continutului vectorului masini [i]. Pe de alta parte \nnici nu poate fi declarat final deoarece valoarea referintei se modifica in functia  \n \npublic void adaugaAutovehicul (Autovehicul x){ \n  if (nrMasini >=masini.length){ \n    masini = Arrays.copyOf(masini, nrMasini +10); //imposibil  cu final masini  \n  } \n  masini[nrMasini ++] = x;  \n} \n \nDaca ar fi final nu se poate face masini =…, insa masini[i] = … este posibil.",
    "Java\nActualizat 9.10.2018\nPrima clasa\nclass Aplicatie1 {\npublic static void main( String args[] )  {\nSystem.out.println( \"Succes !\" ); \n} \n} \nArgumente main()\nclass Aplicatie2 \n{ \npublic static void main( String args[] )  { \nint i; \nSystem.out.println( \"Numarul de argumente este \" \n+ args.length +  \" :\"); \nfor(i=0; i< args.length; i++) \nSystem.out.println (i+  \" -\"  +  args[i] ); \n} \n}\nTipuri de aplicatii Java\nToate aplicatiile Java sunt programe ce cuprind o \nlista de clase. \nIn urma compilarii rezulta un \"cod de octeti\" -\nbytecode -care poate fi executat \n•pe o masina independenta (aplicatii \nstandalone )\n•de catre un browser dupa preluarea de pe \nretea (applet -uri) \nTipuri de date\nTipul \nprimitivDimensiune Valoare \nminimăValoare \nmaximăValoare \nimplicităWrapper Class\nboolean neprecizat1) - - false Boolean\nchar 16-bit Unicode \n0Unicode 216-\n1‘\\x0000 \n(null)Character\nbyte 8-bit -128 +127 (byte)0 Byte\nshort 16-bit -215+215 –1 (short)0 Short\nint 32-bit -231 +231–1 0 Integer\nlong 64-bit",
    "1) - - false Boolean\nchar 16-bit Unicode \n0Unicode 216-\n1‘\\x0000 \n(null)Character\nbyte 8-bit -128 +127 (byte)0 Byte\nshort 16-bit -215+215 –1 (short)0 Short\nint 32-bit -231 +231–1 0 Integer\nlong 64-bit -263 +263–1 0L Long\nfloat 32-bit IEEE754 IEEE754 0.0f Float\ndouble 64-bit IEEE754 IEEE754 0.0d Double\nvoid - - - - Void\n- - - - - BigInteger 2)\n- - - - - BigDecimal 3)\nTablourile in Java sunt obiecte\nbyte x[];  // nealocat , ci doar declarat in stilC++\nbyte [] y; // declarat stilJava\n•x siy au valoarea null\nbyte v[]=new byte[81];  //alocare + v.length\n•v.length are valoarea 81\n•V[0]=0, v[1]=0, …\nInstante sireferinte predefinite\nInstanţe predefinite\nnull –indică faptul că nu s -a atribuit nici o valoare ;    \n-nu poate fi atribuit unei variabile de un tip de date primitiv. \n-poate fi folosita pentru a indica disponibilizarea unui obiect\nThread fir=new Thread(this);\n// ...\nfir = null;\nReferinţe\nthis –o referire explicită la instanţa curentă\nsuper -o referinţă la superclasă\nPachete siclase\np",
    "pentru a indica disponibilizarea unui obiect\nThread fir=new Thread(this);\n// ...\nfir = null;\nReferinţe\nthis –o referire explicită la instanţa curentă\nsuper -o referinţă la superclasă\nPachete siclase\npackage pachet ;\npublic class Punct {// . . . }\nReferirea claselor :\nimport  pachet .*;\n// . . . \nPunct m = new Punct ();\nsau\npachet. Punct m  =  new  pachet. Punct ();\njava.util. Vector v  =   new  java.util. Vector ();\n\nProiect => director\n\n\"\n\nPachet => director\nErori de compilare\npackage datacalendaristica ;\npublic class DataCalendaristica {\nintzi,luna , an=2015;  \npublic static void main(String[] args) {\nzi=10;\nluna =10; \nSystem.out.println ( \"Data \"+ zi+\"/\"+ luna + \"/“ + an );\n}    \n}\n\nDupa corectarea erorilor\n\nInformatia publica NUeste o solutie\nzicrt.zi =37;       // incorect\nzicrt.luna =2;\nzicrt.zi =30;\n// fiecare este corecta considerata separat\nzicrt.zi = zicrt.zi+1;\n//nu se trece la 1 a lunii urmatoare\nSolutia -încapsulare\n\nSolutia -încapsulare\n\nSolutia -încapsulare\n\nSolutia -înc",
    "=2;\nzicrt.zi =30;\n// fiecare este corecta considerata separat\nzicrt.zi = zicrt.zi+1;\n//nu se trece la 1 a lunii urmatoare\nSolutia -încapsulare\n\nSolutia -încapsulare\n\nSolutia -încapsulare\n\nSolutia -încapsulare\nAvantaje\n•Ascunde detaliile de implementare\n•Forteaza utilizatorul sa foloseasca o interfata\n•Permite asigurarea integrității și coerenței \ndatelor\n•Codul devine mai usor de întreținut\nConstructor explicit\n\nConstructor explicit\nCand este prezent un constructor explicit Java nu mai  insereaza automat unul implicit!!!\nConstructor fără argumente\nFunctioneaza în Java 8\nConstructor fără argumente\n\nConstructor fără argumente\n\ntoString(),   @Override\n\ntoString(),   @Override\n\ntoString(),   @Override\n\nExemplu citire si printf\nimport java.util.Scanner ; \nclass Factorial { \npublic static void main(String[] args) { \nlong fact =1 ;\nintn;\nScanner kb = new Scanner(System.in);  \nSystem.out.printf (“n=“);\nn=  kb.nextInt ();\nfor(;n>1; n --)  fact *=n;\nSystem.out.printf (\"%d!=%d\", n, fact); \n}\n}\nEx",
    "ain(String[] args) { \nlong fact =1 ;\nintn;\nScanner kb = new Scanner(System.in);  \nSystem.out.printf (“n=“);\nn=  kb.nextInt ();\nfor(;n>1; n --)  fact *=n;\nSystem.out.printf (\"%d!=%d\", n, fact); \n}\n}\nExemplu citire (String) si printf\nimport java.util.Scanner ; \nclass Factorial { \npublic static void main(String[] args) { \nlong fact =1 ;intn;\nScanner kb = new Scanner(System.in);  \ntry {\nSystem.out.printf (\"n=\");\nn= Integer.parseInt ( kb.nextLine ));\nfor(;n>1; n --)  fact *=n;\nSystem.out.printf (\"%d!=%d\", n, fact); \n} catch ( FormatNumberException e) {\nSystem.out.printf (\"%n%s\", \n\"Eroare: Nu atiintrodus un numar\");\n}\n}\n}\nConverters and Flags \nConverter Flag Explanation\n%d A decimal integer.\n%f A float.\n%nA new line character appropriate to the platform running the application. You should \nalways use %n, rather than \\n.\n%tB A date & time conversion —locale -specific full name of month.\n%td,  % teA date & time conversion —2-digit day of month.",
    "latform running the application. You should \nalways use %n, rather than \\n.\n%tB A date & time conversion —locale -specific full name of month.\n%td,  % teA date & time conversion —2-digit day of month. td has leading zeroes as needed, te \ndoes not.\n%ty, % tY A date & time conversion —ty = 2 -digit year, tY = 4 -digit year.\n%tl A date & time conversion —hour in 12 -hour clock.\n%tM A date & time conversion —minutes in 2 digits, with leading zeroes as necessary.\n%tp A date & time conversion —locale -specific am/pm (lower case).\n%tm A date & time conversion —months in 2 digits, with leading zeroes as necessary.\n%tD A date & time conversion —date as % tm%td%ty\n08 Eight characters in width, with leading zeroes as necessary.\n+ Includes sign, whether positive or negative.\n, Includes locale -specific grouping characters.\n- Left-justified..\n.3 Three places after decimal point.\n10.3 Ten characters in width, right justified, with three places after decimal point.\nSystem.out.format (identic cu print",
    "c grouping characters.\n- Left-justified..\n.3 Three places after decimal point.\n10.3 Ten characters in width, right justified, with three places after decimal point.\nSystem.out.format (identic cu printf )\nlong n = 461012; \nSystem.out.format (\"%d%n \", n); // --> \"461012\" \nSystem.out.format (\"%08d%n\", n); // --> \"00461012\" \nSystem.out.format (\"%+8d%n\", n); // --> \" +461012\" \nSystem.out.format (\"%,8d%n\", n); // --> \" 461,012\" \nSystem.out.format (\"%+,8d%n%n\", n); // --> \"+461,012“\ndouble pi = Math.PI ; \nSystem.out.format (\"%f%n\", pi); // --> \"3.141593\" \nSystem.out.format (\"%.3f%n\", pi); // --> \"3.142\" \nSystem.out.format (\"%10.3f%n\", pi); // --> \" 3.142\" \nSystem.out.format (\"%-10.3f%n\", pi); // --> \"3.142\" \nSystem.out.format (Locale.FRANCE , \"%-10.4f%n%n\", pi); \n// -->\"3,1416\" \nString.format (sprintf )\nString fs; \nfloat x=14.12536;   \nintn=10;\nfs = String.format (\"x= % f%n \" + \"n=%7d\", x, n); \nSystem.out.println (fs); \nx=14.12536 \nn=            10\nbreak cu eticheta\nint[][] mat = { \n{ 30, -10",
    "rintf )\nString fs; \nfloat x=14.12536;   \nintn=10;\nfs = String.format (\"x= % f%n \" + \"n=%7d\", x, n); \nSystem.out.println (fs); \nx=14.12536 \nn=            10\nbreak cu eticheta\nint[][] mat = { \n{ 30, -10, 11},\n{ -2, 41, 118 }  \n};\nintval= 118;\ncauta:\nfor (i= 0; i< mat.length ; i++) \nfor (j = 0; j < mat[ i].length; j++) \nif ( mat [ i][j] == val) \nbreak cauta;\nInstructiunea for -Java 8\nclass VectorIntregi {\npublic static void main(String[] args){\nint[] vect= {100,200,300};        \nfor (intn : vect) {\nSystem.out.println (“N= \" + n);\n}\n}\n}\nN= 100\nN= 200\nN= 300\nSe recomanda utilizarea acestei formepentruparcurgerea\nvectorilor .\nhttp://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.\nhtml\nMoștenire\nclass Parinte {\n}\nclass Copil extends Parinte {\n// moștenește câmpurile și metodele public si protected din clasa Parinte\n//  -daca clasa Copil se gaseste in acelasi pachet cu Parinte mosteneste si câmpurile și \n//     metodele declarate fara un modificator de acces (cel implicit sau package -p",
    "rotected din clasa Parinte\n//  -daca clasa Copil se gaseste in acelasi pachet cu Parinte mosteneste si câmpurile și \n//     metodele declarate fara un modificator de acces (cel implicit sau package -private )\n}\n•În Java o clasă poate extinde o singură clasă părinte (superclasă)\n•Dacă nu este precizat extends atunci clasa respectivă extinde clasa \nObject din java.lang\nclass Parinte extends Object {//e redundant extends Object\n}\n•Object este superclasa tuturor claselor Java.\nclass A {\nint i=1;\npublic A(){\nSystem .out.println (\"Object()\" );  //inainte s-a apelat constr uctorul clasei parinte\nSystem .out.println (\"A()  i=\"+i);\n}\n}\nclass B extends A{\nint j=2;\npublic B(){\nSystem .out.println (\"B()  j=\" +j);\n}\n}\nclass C extends B {\nint k=3;\npublic C(){\nSystem .out.println (\"C()  k=\" +k);\n}\n}\npublic class Abc {\npublic static void main (String [] args) {\nC objc = new C();\nSystem .out.println (\"\\nobjc.i =\"+  objc .i+ \",  objc.j =\"+ objc .j+ \",  objc.k =\" + objc .k);\n}\n}\n\nclass A {\nint i=1;\npubli",
    "ic class Abc {\npublic static void main (String [] args) {\nC objc = new C();\nSystem .out.println (\"\\nobjc.i =\"+  objc .i+ \",  objc.j =\"+ objc .j+ \",  objc.k =\" + objc .k);\n}\n}\n\nclass A {\nint i=1;\npublic A(){\nSystem .out.println (\"Object()\" );  //inainte s-a apelat constr uctorul clasei parinte\nSystem .out.println (\"A()  i=\"+i);\n}\n}\nclass B extends A{\nint j=2;\npublic B(){\nSystem .out.println (\"B()  j=\" +j);\n}\n}\nclass C extends B {\nint k=3;\npublic C(){\nSystem .out.println (\"C()  k=\" +k);\n}\n}\npublic class Abc {\npublic static void main (String [] args) {\nC objc = new C();\nSystem .out.println (\"objc.i =\"+  objc .i+ \n\",  objc.j =\"+ objc .j+ \",  objc.k =\" + objc .k);\n}\n}\nObject()\nA()  i=1\nB()  j=2\nC()  k=3\nobjc.i =1,  objc.j =2,  objc.k =3\nclass A {\nint i=1;\npublic A(){\nsuper();               //implicit se apel eaza constr uctorul clasei parinte\nSystem .out.println (\"Object()\" );  \nSystem .out.println (\"A()  i=\"+i);\n}\n}\nclass B extends A{\nint j=2;\npublic B(){\nsuper ();               //implicit",
    "plicit se apel eaza constr uctorul clasei parinte\nSystem .out.println (\"Object()\" );  \nSystem .out.println (\"A()  i=\"+i);\n}\n}\nclass B extends A{\nint j=2;\npublic B(){\nsuper ();               //implicit se apel eaza constr uctorul clasei parinte\nSystem .out.println (\"B()  j=\" +j);\n}\n}\nclass C extends B {\nint k=3;\npublic C(){\nsuper ();               //implicit se apel eaza constr uctorul clasei parinte\nSystem .out.println (\"C()  k=\" +k);\n}\n}\npublic class Abc {\npublic static void main (String [] args) {\nC objc = new C();\nSystem .out.println (\"objc.i =\"+  objc .i+ \n\",  objc.j =\"+ objc .j+ \",  objc.k =\" + objc .k);\n}\n}\nObject()\nA()  i=1\nB()  j=2\nC()  k=3\nobjc.i =1,  objc.j =2,  objc.k =3\nInițializarea câmpurilor\nExemple\nint val;       // val=0, la fel byte, short , long cu 0,  float si double cu 0.0; boolean \ncu False\nPunct p = new Punct (2,3) ;       // p este o referință nenulă\nint x[];            //  variable x might not have been initialized\nfloat [][] y;      // variable y might not hav",
    "0.0; boolean \ncu False\nPunct p = new Punct (2,3) ;       // p este o referință nenulă\nint x[];            //  variable x might not have been initialized\nfloat [][] y;      // variable y might not have been initialized\nfloat mat[][] = new float [10][];   //mat=[[F@30dae81 mat[9]=null, \n// mat[9][0] ->Exception NullPointer …\nfloat [][] w= new float [10][5];     // w=[[F@1b2c6ec2   w[0][0]=0.0\nOrdinea de inițializare la construirea unui\nobiect\n1.se apelează constructorul clasei părinte \n2.se execută inițializările câmpurilor clasei \n3.se execută instruc țiunile din constructorul clasei respective\nclass Initializare {\npublic Initializare (int i) {\nSystem .out.println (\"Initializare x\"+i);\n}\n}\nclass D {\nint i=1\nInitializare x1 = new Initializare (1);\npublic D(){\nSystem .out.println (\"D()\" );\nInitializare x2 = new Initializare (2);\n}\nInitializare x3 = new Initializare (3);\n}class E extends D{\nint j=2;\nInitializare x4 = new Initializare (4);\npublic E(){\nInitializare x5 = new Initializare (5)",
    "nitializare x2 = new Initializare (2);\n}\nInitializare x3 = new Initializare (3);\n}class E extends D{\nint j=2;\nInitializare x4 = new Initializare (4);\npublic E(){\nInitializare x5 = new Initializare (5);\nSystem .out.println (\"B()\" );\nInitializare x6 = new Initializare (6);\n}\n}\npublic class DemoInitializari {\nInitializare x7 = new Initializare (7);\npublic static void main (String [] args)  {\nInitializare x8 = new Initializare (8);\nSystem .out.println (\"main: se vaexecuta \"+\n\" E obje = new E();\" );\nE obje = new E();\nInitializare x9 = new Initializare (9);\nDemoInitializari d = new DemoInitializari ();\n}\n}Ordinea de initializarea a campurilor claselor\npublic class DemoInitializari {\nInitializare x7 = new Initializare (7);\npublic static void main (String [] args)  {\nInitializare x8 = new Initializare (8);\nSystem .out.println (\"main: se vaexecuta \"+\n\" E obje = new E();\" );\nE obje = new E();\nInitializare x9 = new Initializare (9);\nDemoInitializari d = new DemoInitializari ();\n}\n}\nclass D {\nint",
    "zare (8);\nSystem .out.println (\"main: se vaexecuta \"+\n\" E obje = new E();\" );\nE obje = new E();\nInitializare x9 = new Initializare (9);\nDemoInitializari d = new DemoInitializari ();\n}\n}\nclass D {\nint i=1\nInitializare x1 = new Initializare (1);\npublic D(){\nSystem .out.println (\"D()\" );\nInitializare x2 = new Initializare (2);\n}\nInitializare x3 = new Initializare (3);\n}\nInitializare x8\nmain: se vaexecuta E obje= \nnew E();\nInitializare x1\nInitializare x3\nD()\nInitializare x2Ordinea de initializarea a campurilor claselor\nInitializare x4\nInitializare x5\nB()\nInitializare x6\nInitializare x9\nInitializare x7      class E extends D{\nint j=2;\nInitializare x4 = new Initializare (4);\npublic E(){\nInitializare x5 = new Initializare (5);\nSystem .out.println (\"B()\" );\nInitializare x6 = new Initializare (6);\n}\n}\npublic class DemoInitializari {\nInitializare x7 = new Initializare (7);\npublic static void main (String [] args)  {\nInitializare x8 = new Initializare (8);\nSystem .out.println (\"main: se vaexecuta",
    "}\n}\npublic class DemoInitializari {\nInitializare x7 = new Initializare (7);\npublic static void main (String [] args)  {\nInitializare x8 = new Initializare (8);\nSystem .out.println (\"main: se vaexecuta \"+\n\" E obje = new E();\" );\nE obje = new E();\nInitializare x9 = new Initializare (9);\nDemoInitializari d = new DemoInitializari ();\n}\n}Ordinea de initializarea a campurilor claselor\nConstructori și Moștenire\nO clasă NU moștenește constructorii de la \nclasa părinte. \nSoluții:\n1.se utilizează constructorul implicit \n(trebuie să existe în clasa părinte)\n2.se scriu unul sau mai mulți constructori \nexpliciți\nMostenire\n\nMostenire\n\nMostenire",
    "Programare Java (2)\nprof.dr.ing. Ștefan -Gheorghe Pentiuc\nModificator CLASĂ METODĂ VARIABILĂ\npublic acces permis \ntuturor claselorpoate fi apelată din orice clasă poate fi consultată /\nmodificată din orice clasă\nprivate - nu poate fi apelată decât din \nclasa respectivănu poate fi consultată /\nmodificată decât din clasa \nrespectivă\nprotected - poate fi apelată din clasa \nrespectivă, subclasele şi \nclasele aceluiaşi pachetpoate fi consultată /\nmodificată din clasa \nrespectivă, subclasele şi \nclasele aceluiaşi pachet\n-\n(fără\nmodificator\n)clasa este \naccesibilă claselor \ndin acelaşi pachet poate fi apelată din clasa \nrespectivă şi din  clasele \naceluiași pachetpoate fi consultată /\nmodificată din clasa \nrespectivă şi din  clasele \naceluiași pachet\nModificator CLASĂ METODĂ VARIABILĂ\nabstract defineşte o \nclasă şablon \n(abstractă)metodă şablon (fără a \ndefini corpul funcţiei )-\nstatic - nu poate fi redefinita in \nsubclase \nmetoda poate fi referirta \nclasa.metoda () variabilă globală \nobiecte",
    "fineşte o \nclasă şablon \n(abstractă)metodă şablon (fără a \ndefini corpul funcţiei )-\nstatic - nu poate fi redefinita in \nsubclase \nmetoda poate fi referirta \nclasa.metoda () variabilă globală \nobiectelor clasei\nfinal nu are subclase nu mai poate fi redefinită în \nsubclaseconstantă\nfinal static - - globală , nu poate fi \nmodificată în subclase\nAccesul la membrii unei clase\nModificator Clasă Pachet Subclas ă Exterior\npublic Da Da Da Da\nprotected Da Da Da NU\nFără\nmodificatorDa Da NU NU\nprivate Da NU NU NU\nFără modificator (implicit)  =  protejat la nivel de pachet (package \nprivate)\nVizibilitatea membrilor clasei Alpha\nModifi cator Alpha Beta Alphasub Gamma\npublic Da Da Da Da\nprotected Da Da Da Nu\nfără modificator Da Da Nu Nu\nprivate Da Nu Nu Nu\nhttps://docs.oracle.com/javase/tutorial/java/javaOO/accesscoNutrol.html\nSfaturi\n•utilizati celmai restrictiv mod de acces cu \nputință\n•private nu va fi utilizat decât dacă este un \nmotiv să nu fie utilizat\n•de evitat public pentru câmpuri; excepți",
    "vaOO/accesscoNutrol.html\nSfaturi\n•utilizati celmai restrictiv mod de acces cu \nputință\n•private nu va fi utilizat decât dacă este un \nmotiv să nu fie utilizat\n•de evitat public pentru câmpuri; excepție \nconstantele \npublic final int NMAX=100;\nMoștenire și modificatorii de acces\nJava interzice reducerea accesului în \nclasele de rivate !\nTrebuie ca metodele suprascrise in clasele copil \nsa poată fi accesate la fel  ca cele din clasa \npărinte.\nMoștenire\npackage adnotare ;\npublic class Parinte {\npublic void afis(String sir) {\nSystem.out.println (\"Afis parinte : ” +sir);\n}\n}\nMoștenire\npackage adnotare ;\npublic class Copil extends Parinte {\nprotected void afis(String sir){\nSystem.out.println (\"Afis copil : \"+sir);\n}\n}\nerror : afis(String) in Copil cannot override afis(String) in Parinte\nprotected void afis(String sir){\nattempting to assign weaker access privileges ; was public\nPOLIMORFISM\nAtribuiri polimorfe\nStudent s;\nStudentIng x,y;\nStudentSIC d;\nciteste c;\n//\nd= new StudentSIC (\"Numex\",\"P",
    "d void afis(String sir){\nattempting to assign weaker access privileges ; was public\nPOLIMORFISM\nAtribuiri polimorfe\nStudent s;\nStudentIng x,y;\nStudentSIC d;\nciteste c;\n//\nd= new StudentSIC (\"Numex\",\"Prenumex\",20 20,true);\n// atribuiri corecte\nx=d;// StudentIng estesuperclasa luiStudentSIC\ns=x;  // Student estesuperclasa luiStudentIng\ns=d;  // Student estesisuperclasa luiStudentSIC\ny=x;  // de acelasi tipStudent\nStudentIng\nStudentSIC\nAtribuiri polimorfe\nObject o;\n// atribuiri corecte\no=s;  // Object este superclasa tuturor\no=y;\no=d;\no=c;Student\nStudentIng\nStudentSICObject\nciteste\nAtribuiri polimorfe INCORECTE\n/*  atribuiri eronate\nd=x;  //  incompatible types\n// required: Studenti.StudentSIC\nx=s;  // required: Studenti.StudentIng\nd=s;  // required: Studenti.StudentSIC\ns=o;  // required: Studenti.Student\nx=o;  // required: Studenti.StudentIng\nd=o;  // required: Studenti.StudentSIC\nc =s;  //required: citeste\nc=o;\n*/Student s;\nStudentIng x,y;\nStudentSIC d;\nciteste c;\nObject o;\nStudent\nStud",
    "denti.Student\nx=o;  // required: Studenti.StudentIng\nd=o;  // required: Studenti.StudentSIC\nc =s;  //required: citeste\nc=o;\n*/Student s;\nStudentIng x,y;\nStudentSIC d;\nciteste c;\nObject o;\nStudent\nStudentIng\nStudentSIC\nTablouri polimorfe\nStudentIng  d = new StudentIng(...);\nStudentSIC  bun = new StudentSIC(...);\nStudent     a = new Student(...);\nStudent[] grup=new Student[] {d,bun,a};\nfor(Student s: grup) \nSystem.out.println (s);Student\nStudentIng\nStudentSIC\nTablouri polimorfe\nStudentIng d= new StudentIng(...);\nStudentSIC bun=new StudentSIC(...);\nStudent    a=new Student(...);\nciteste   c= new citeste();\nObject    o= new Object();\nObject[]vector =new Object[]{d,bun,a,c,o};\nfor(Objectv: vector)\nSystem.out.println (v);Student\nStudentIng\nStudentSICObject\nciteste\nPolimorfism\nclass StudentIng extends Student {\nintan;\npublic void promovat () {\nintan_terminal =4;\nif (this instanceof StudentSIC )\nan_terminal =6;\nif(an+1<= an_terminal ) an++;    \n} \n//...",
    "t\nciteste\nPolimorfism\nclass StudentIng extends Student {\nintan;\npublic void promovat () {\nintan_terminal =4;\nif (this instanceof StudentSIC )\nan_terminal =6;\nif(an+1<= an_terminal ) an++;    \n} \n//... \npublic static void main(String args[]){\nStudent[] grup=new Student[]{ing1,sic1,sic2,ing3};\nfor(Student s: grup) s.promovat ();\n}\n}Student\nStudentIng\nStudentSIC\nExemplu complet cu un  tablou polimorf\nAplicatie : Gestiunea unei grădini zoologice care \nadăpostește mai multe animale diferite: lei, tigri, \nmaimuțe.\nModelarea lor în POO conduce a ierarhia de clase:\n\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n}\nclass Leu extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println (this + \" se plimba \");\n}\n@Override\npublic String toString () {\nreturn \"Leu\" ;\n}\n}\nclass Tigru extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println ( this +\" zambeste \");\n}\n}\nclass Maimuta extends Animal {\n}\n\nclass Animal {\npublic void ceFace (){",
    "eturn \"Leu\" ;\n}\n}\nclass Tigru extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println ( this +\" zambeste \");\n}\n}\nclass Maimuta extends Animal {\n}\n\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n}\nclass Leu extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println (this + \" se plimba \");\n}\n@Override\npublic String toString () {\nreturn \"Leu\" ;\n}\n}\nclass Tigru extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println ( this +\" zambeste \");\n}\n}\nclass Maimuta extends Animal {\n}\npublic class Zoo {\npublic static void main (String [] args) {\nAnimal [] zoo = new Animal[ 4];\nzoo[0]= new Leu();\nzoo[1] = new Tigru ();\nzoo[2] = new Animal();\nzoo[3] = new Maimuta ();\nSystem .out.println (\"In Zoo avem :\");\nfor (int i= 0; i< zoo.length ; i++) {\nSystem .out.println (zoo[i]+\"    \" );\n}\n}\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n}\nclass Leu extends Animal {\n@Override\npublic void c",
    "oo.length ; i++) {\nSystem .out.println (zoo[i]+\"    \" );\n}\n}\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n}\nclass Leu extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println (this + \" se plimba \");\n}\n@Override\npublic String toString () {\nreturn \"Leu\" ;\n}\n}\nclass Tigru extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println ( this +\" zambeste \");\n}\n}\nclass Maimuta extends Animal {\n}public class Zoo {\npublic static void main (String [] args) {\nAnimal [] zoo = new Animal[ 5];\nzoo[0]= new Leu();\nzoo[1] = new Tigru ();\nzoo[2] = new Animal();\nzoo[3] = new Maimuta ();\nSystem .out.println (\"In Zoo avem :\");\nfor (int i= 0; i< zoo.length ; i++) {\nSystem .out.println (zoo[i]+\"    \" );\n}\n}\nCare este afișarea produsă de program ?\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n}\nclass Leu extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println (this + \" se plimba \");\n}\n@Over",
    "lass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n}\nclass Leu extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println (this + \" se plimba \");\n}\n@Override\npublic String toString () {\nreturn \"Leu\" ;\n}\n}\nclass Tigru extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println ( this +\" zambeste \");\n}\n}\nclass Maimuta extends Animal {\n}public class Zoo {\npublic static void main (String [] args) {\nAnimal [] zoo = new Animal [5];\nzoo[0]= new Leu();\nzoo[1] = new Tigru ();\nzoo[2] = new Animal();\nzoo[3] = new Maimuta ();\nSystem .out.println (\"In Zoo avem :\");\nfor (int i= 0; i< zoo.length ; i++) {\nSystem .out.println (zoo[i]+\"    \" );\n}\n}\nCare este afișarea produsă de program ?\nIn Zoo avem:\nLeu    \nro.usv.Tigru@27d6c5e0    \nro.usv.Animal@4f3f5b24    \nro.usv.Maimuta@15aeb7ab    \nnull\nDe cetoString ()din clasa Object a afisat\npentru zoo[1] ro.usv.Tigru@27d6c5e0 \njava.lang.",
    "m ?\nIn Zoo avem:\nLeu    \nro.usv.Tigru@27d6c5e0    \nro.usv.Animal@4f3f5b24    \nro.usv.Maimuta@15aeb7ab    \nnull\nDe cetoString ()din clasa Object a afisat\npentru zoo[1] ro.usv.Tigru@27d6c5e0 \njava.lang. Class\nInstan țeale clasei Class reprezintă clasele, interfețele în timpul \nexecuției unui program Java.\nPentru fiecare clasă dintr -un program Java si pentru toate tablourile \nJVM creează câteun obiect de tip Class\nÎn continuare se prezintă metode ale claselor Object și Class preluate \ndinJava API Documentation\nhttps://docs.oracle.com/en/java/javase/15/docs/api/index.html\nModifier and TypeMethod Description\nprotected\nObjectclone () Creates and returns a copy of this object.\nboolean equals ​(Object obj) Indicates whether some other object is \"equal to\" this one.\nprotected void finalize () Deprecated. The finalization mechanism is inherently \nproblematic.\nClass <?> getClass () Returns the runtime class of this Object.\nint hashCode () Returns a hash code value for the object.\nvoid notify ()",
    "ecated. The finalization mechanism is inherently \nproblematic.\nClass <?> getClass () Returns the runtime class of this Object.\nint hashCode () Returns a hash code value for the object.\nvoid notify () Wakes up a single thread that is waiting on this object's \nmonitor.\nvoid notifyAll () Wakes up all threads that are waiting on this object's monitor.\nString toString () Returns a string representation of the object.\nvoid wait () Causes the current thread to wait until it is awakened, typically \nby being notified orinterrupted.\nvoid wait ​(long timeoutMillis ) Causes the current thread to wait until it is awakened, typically \nby being notified orinterrupted, or until a certain amount of \nreal time has elapsed.\nvoid wait ​(long timeoutMillis , \nintnanos)Causes the current thread to wait until it is awakened, typically \nby being notified orinterrupted, or until a certain amount of \nreal time has elapsed.java.lang.",
    "wait ​(long timeoutMillis , \nintnanos)Causes the current thread to wait until it is awakened, typically \nby being notified orinterrupted, or until a certain amount of \nreal time has elapsed.java.lang. Object Method Summary\njava.lang. Class Method Summary (selecție)\nstatic Class <?\n>forName ​(\nString className )Returns the Class object associated with the class or interface with the given \nstring name.\nConstructor <\n?>[]getConstructors () Returns an array containing Constructor objects reflecting all the public \nconstructors of the class represented by this Class object.\nField [] getFields () Returns an array containing Field objects reflecting all the accessible public fields of \nthe class or interface represented by this Class object.\nClass <?>[] getInterfaces () Returns the interfaces directly implemented by the class or interface represented \nby this object.\nMethod [] getMethods () Returns an array containing Method objects reflecting all the public methods of the \nclass or interfac",
    "rectly implemented by the class or interface represented \nby this object.\nMethod [] getMethods () Returns an array containing Method objects reflecting all the public methods of the \nclass or interface represented by this Class object, including those declared by the \nclass or interface and those inherited from superclasses and superinterfaces .\nint getModifiers () Returns the Java language modifiers for this class or interface, encoded in an \ninteger.\nString getName () Returns the name of the entity (class, interface, array class, primitive type, or void) \nrepresented by this Class object, as a String.\nString getSimpleName () Returns the simple name of the underlying class as given in the source code.\nClass <? \nsuper T>getSuperclass () Returns the Class representing the direct superclass of the entity (class, interface, \nprimitive type or void) represented by this Class.\nboolean isArray () Determines if this Class object represents an array class.\nboolean isEnum () Returns true if and",
    "of the entity (class, interface, \nprimitive type or void) represented by this Class.\nboolean isArray () Determines if this Class object represents an array class.\nboolean isEnum () Returns true if and only if this class was declared as an enum in the source code.\nboolean isInterface () Determines if the specified Class object represents an interface type.\nDe cetoString ()din clasa Object a afisat\npentru zoo[1] ro.usv.Tigru@27d6c5e0 \njava.lang. Class\nString toString () –o reprezentare sub forma “clasa@nrHexazecimal ”\nClass getClass () –returnează clasa obiectului (un obiect de tip Class)\njava.lang. Class\nString getName () –returneaza numele complet al clasei ( pachet.clasă )\nString getSimpleName () -returneaza numele clasei fără denumirea\npachetului\nExemplu . Fie Leu obj= new Leu() ;\nObținerea clasei unui obiect:      obj.getClass ()   ------>   un obiect de tip Class\nNumele complet al clasei:           obj.getClass ().getName () --->  \"ro.usv.Leu ”\nNumele clasei fără den.pachet :  obj.",
    "rea clasei unui obiect:      obj.getClass ()   ------>   un obiect de tip Class\nNumele complet al clasei:           obj.getClass ().getName () --->  \"ro.usv.Leu ”\nNumele clasei fără den.pachet :  obj.getClass ().getSimpleName ()-->  “Leu \"\nMetoda toString () din clasa Object\npublic class Object {\n// . . . \npublic String toString () {\nreturn getClass ().getName () + \"@\" + \nInteger .toHexString (hashCode ());\n}\n// . . . \npublic native inthashCode ();\n// . . . \n}\n---> ro.usv.Tigru @27d6c5e0\ngetClass ().getName () @   Integer .toHexString (hashCode ())\nPentru a afisa doar numele simplu al \nclaselor obiectelor din tabloul Animal zoo[]\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n@Override\npublic String toString () {\nreturn getClass(). getSimpleName ();\n}\n}\n\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n@Override\npublic String toString () {\nreturn getClass().",
    "toString () {\nreturn getClass(). getSimpleName ();\n}\n}\n\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n@Override\npublic String toString () {\nreturn getClass(). getSimpleName ();\n}\nclass Leu extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println (this + \" se plimba \");\n}\n@Override\npublic String toString () {\nreturn \"Leu\" ;\n}\n}\nclass Tigru extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println ( this +\" zambeste \");\n}\n}class Maimuta extends Animal {\n}\npublic class Zoo {\npublic static void main (String [] args) {\nAnimal [] zoo = new Animal[4];\nzoo[0]= new Leu();\nzoo[1] = new Tigru ();\nzoo[2] = new Animal();\nzoo[3] = new Maimuta ();\nSystem .out.println (\"In Zoo avem :\");\nfor (int i= 0; i< zoo.length ; i++) {\nSystem .out.println (zoo[i]+\"    \" );\n}\n}\nCare este afișarea produsă de program ?\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n@Override\npublic String toString () {\nreturn",
    "rintln (zoo[i]+\"    \" );\n}\n}\nCare este afișarea produsă de program ?\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n@Override\npublic String toString () {\nreturn getClass(). getSimpleName ();\n}\nclass Leu extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println (this + \" se plimba \");\n}\n@Override\npublic String toString () {\nreturn \"Leu\" ;\n}\n}\nclass Tigru extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println ( this +\" zambeste \");\n}\n}class Maimuta extends Animal {\n}\npublic class Zoo {\npublic static void main (String [] args) {\nAnimal [] zoo = new Animal[4];\nzoo[0]= new Leu();\nzoo[1] = new Tigru ();\nzoo[2] = new Animal();\nzoo[3] = new Maimuta ();\nSystem .out.println (\"In Zoo avem :\");\nfor (int i= 0; i< zoo.length ; i++) {\nSystem .out.println (zoo[i]+\"    \" );\n}\n}\nCare este afișarea produsă de program ?\nIn Zoo avem:\nLeu    \nTigru\nAnimal\nMaimuta    \nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face",
    "ystem .out.println (zoo[i]+\"    \" );\n}\n}\nCare este afișarea produsă de program ?\nIn Zoo avem:\nLeu    \nTigru\nAnimal\nMaimuta    \nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n@Override\npublic String toString () {\nreturn getClass(). getSimpleName ();\n}\nclass Leu extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println (this + \" se plimba \");\n}\n@Override\npublic String toString () {\nreturn \"Leu\" ;\n}\n}\nclass Tigru extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println ( this +\" zambeste \");\n}\n}class Maimuta extends Animal {\n}\npublic class Zoo {\npublic static void main (String [] args) {\nAnimal [] zoo = new Animal[4];\nzoo[0]= new Leu();\nzoo[1] = new Tigru ();\nzoo[2] = new Animal();\nzoo[3] = new Maimuta ();\nSystem .out.println (\"In Zoo avem :\");\nfor (int i= 0; i< zoo.length ; i++) {\nSystem .out.println (zoo[i]+\"    \" );\n}\n}\nCare este afișarea produsă de program ?\nIn Zoo avem:\nLeu    \nTigru\nAnimal\nMaimuta    \nclass Animal {",
    "(\"In Zoo avem :\");\nfor (int i= 0; i< zoo.length ; i++) {\nSystem .out.println (zoo[i]+\"    \" );\n}\n}\nCare este afișarea produsă de program ?\nIn Zoo avem:\nLeu    \nTigru\nAnimal\nMaimuta    \nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n@Override\npublic String toString () {\nreturn getClass(). getSimpleName ();\n}\nclass Leu extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println (this + \" se plimba \");\n}\n@Override\npublic String toString () {\nreturn \"Leu\" ;\n}\n}\nclass Tigru extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println ( this +\" zambeste \");\n}\n}class Maimuta extends Animal {\n}\npublic class Zoo {\npublic static void main (String [] args) {\nAnimal [] zoo = new Animal[4];\nzoo[0]= new Leu();\nzoo[1] = new Tigru ();\nzoo[2] = new Animal();\nzoo[3] = new Maimuta ();\nSystem .out.println (\"Ce fac “ +    \n\"pensionarii din Zoo:\" );\nfor(Animal a : zoo)\na.ceFace ();\n} \n}\nCare este afișarea produsă de program ?}\nclass Animal {\npubli",
    "ew Animal();\nzoo[3] = new Maimuta ();\nSystem .out.println (\"Ce fac “ +    \n\"pensionarii din Zoo:\" );\nfor(Animal a : zoo)\na.ceFace ();\n} \n}\nCare este afișarea produsă de program ?}\nclass Animal {\npublic void ceFace (){\nSystem .out.println (this + \" face cepoate \");\n}\n@Override\npublic String toString () {\nreturn getClass(). getSimpleName ();\n}\nclass Leu extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println (this + \" se plimba \");\n}\n@Override\npublic String toString () {\nreturn \"Leu\" ;\n}\n}\nclass Tigru extends Animal {\n@Override\npublic void ceFace () {\nSystem .out.println ( this +\" zambeste \");\n}\n}class Maimuta extends Animal {\n}\npublic class Zoo {\npublic static void main (String [] args) {\nAnimal [] zoo = new Animal[4];\nzoo[0]= new Leu();\nzoo[1] = new Tigru ();\nzoo[2] = new Animal();\nzoo[3] = new Maimuta ();\nSystem .out.println (\"Ce fac “ +    \n\"pensionarii din Zoo:\" );\nfor(Animal a : zoo)\na.ceFace ();\n} \n}\nCare este afișarea produsă de program ?\nCe fac pensionarii dinZoo:",
    "imal();\nzoo[3] = new Maimuta ();\nSystem .out.println (\"Ce fac “ +    \n\"pensionarii din Zoo:\" );\nfor(Animal a : zoo)\na.ceFace ();\n} \n}\nCare este afișarea produsă de program ?\nCe fac pensionarii dinZoo:\nLeuse plimba\nTigru zambeste\nAnimal face ce poate\nMaimuta face ce poate}\nDacătabloul zoo[] arfi de tip Object\nObject [] zoo = new Object[ 5];\nzoo[0]= new Leu();\nzoo[1] = new Tigru ();\nzoo[2] = new Animal();\nzoo[3] = new Maimuta ();\nzoo[4] = new Punct ();          // nu era posibil pt. Animal zoo[]...\nSystem .out.println (\"Ce fac pensionarii din Zoo:\" );\nfor(Object a : zoo){\n((Animal )a).ceFace ();       // era eroare pentru a.ceFace ()\n}\nCare este rezultatul executiei ?\nDacătabloul zoo[] arfi de tip Object\nObject [] zoo = new Object[ 5];\nzoo[0]= new Leu();\nzoo[1] = new Tigru ();\nzoo[2] = new Animal();\nzoo[3] = new Maimuta ();\nzoo[4] = new Punct ();          // nu era posibil pt. Animal zoo[]...\nSystem .out.println (\"Ce fac pensionarii din Zoo:\" );\nfor(Object a : zoo){\n((Animal )a).ceFace (",
    "nimal();\nzoo[3] = new Maimuta ();\nzoo[4] = new Punct ();          // nu era posibil pt. Animal zoo[]...\nSystem .out.println (\"Ce fac pensionarii din Zoo:\" );\nfor(Object a : zoo){\n((Animal )a).ceFace ();       // era eroare pentru a.ceFace ()\n}\nCe facpensionarii din Zoo:\nLeu se plimba\nTigru zambeste\nAnimal face cepoate\nMaimuta face cepoate\nException in thread \"main\" java.lang.ClassCastException : \nclass ro.usv.Punct cannot be cast to class ro.usv.Animal (ro.usv.Punct and \nro.usv.Animal are in unnamed module of loader 'app’)  \nat ro.usv.Zoo.main (Zoo.java:58)\nMoștenire\npackage adnotare ;\npublic class Parinte {\npublic void afis(String sir) {\nSystem.out.println (\"Afis parinte : ” +sir);\n}\n}\nMoștenire\npackage adnotare ;\npublic class Copil extends Parinte {\n@Override\npublic void afis(String sir){\nSystem.out.println (\"Afis copil : \"+sir);\n}\n}\nPolimorfism\npackage adnotare ;\npublic class TestParinteCopil {\npublic static void main(String[] args ) { \nParinte pp= new Parinte ();\nParinte pc= new Co",
    "{\nSystem.out.println (\"Afis copil : \"+sir);\n}\n}\nPolimorfism\npackage adnotare ;\npublic class TestParinteCopil {\npublic static void main(String[] args ) { \nParinte pp= new Parinte ();\nParinte pc= new Copil ();\nCopil cc= new Copil ();\n//      Copil cp= new Parinte ();  // Parinte cannot be converted to Copil\npp.afis (\"pp 1\");\npc.afis (\"pc 2\");\ncc.afis (\"cc 3\");\n}\n}\nPolimorfism\npackage adnotare ;\npublic class TestParinteCopil {\npublic static void main(String[] args ) { \nParinte pp= new Parinte ();\nParinte pc= new Copil ();\nCopil cc= new Copil ();\n//      Copil cp= new Parinte ();  // Parinte cannot be converted to Copil\npp.afis (\"pp 1\");\npc.afis (\"pc 2\");\ncc.afis (\"cc 3\");\n}\n}Afis parinte : pp 1\nAfis copil : pc 2\nAfis copil : cc 3\nPolimorfism\npackage adnotare ;\npublic class TestParinteCopil {\npublic static void main(String[] args) {   \nParinte pp= new Parinte ();\nParinte pc= new Copil ();\nCopil cc= new Copil ();\n//    Copil cp= new Parinte ();  // eroare Parinte cannot be converted to Copi",
    "public static void main(String[] args) {   \nParinte pp= new Parinte ();\nParinte pc= new Copil ();\nCopil cc= new Copil ();\n//    Copil cp= new Parinte ();  // eroare Parinte cannot be converted to Copil\npp.afis (\"pp 1\");\npc.afis (\"pc 2\");\ncc.afis (\"cc 3\");\nSystem.out.println (\" Clasa objrefdepc \"+ pc.getClass ().getName ());\n}\n}\nPolimorfism\npackage adnotare ;\npublic class TestParinteCopil {\npublic static void main(String[] args) {   \nParinte pp= new Parinte ();\nParinte pc= new Copil ();\nCopil cc= new Copil ();\n//    Copil cp= new Parinte ();  // eroare Parinte cannot be converted to Copil\npp.afis (\"pp 1\");\npc.afis (\"pc 2\");\ncc.afis (\"cc 3\");\nSystem.out.println (\"Clasa objrefdepc \"+ pc.getClass ().getName ());\n}\n} Clasa obj ref de pc  adnotare.CopilAfis parinte : pp 1\nAfis copil : pc 2\nAfis copil : cc 3\nInvocarea metodei virtuale\nMașina virtuală Java (JVM) apelează\ntotdeauna metoda ceamai potrivit ă \npentru obiectul referi t de o variabilă\n(exemplu Parinte pc= new Copil();  ).",
    "pc 2\nAfis copil : cc 3\nInvocarea metodei virtuale\nMașina virtuală Java (JVM) apelează\ntotdeauna metoda ceamai potrivit ă \npentru obiectul referi t de o variabilă\n(exemplu Parinte pc= new Copil();  ). \nNu se apelează metoda definită\nde tipul variabilei (în exemplu \nParinte ), ci metoda cea mai \nadecvată tipului obiectului referit \nde variabilă pc(Copil ).\nDar dacă ar fi metode diferite, însă cu \nacelași nume ?\npackage adnotare ;\npublic class Parinte {\npublic void afis(Object sir){\nSystem.out.println (\"Afis parinte : ” +sir);\n}\n}\npublic class Copil extends Parinte {\n// @Override error: method does not override or implement a method from a supertype\npublic void afis(String sir){\nSystem.out.println (\"Afis copil : \"+sir);\n}\n} Atentie. S -a renuntat la @Override\nExistă 2 metode diferite afis(). \nUna în clasa Parinte și una în clasa Copil\npackage adnotare ;\npublic class TestParinteCopil {\npublic static void main(String[] args ) { \nParinte pp= new Parinte ();\nParinte pc= new Copil ();\nCopil c",
    "Una în clasa Parinte și una în clasa Copil\npackage adnotare ;\npublic class TestParinteCopil {\npublic static void main(String[] args ) { \nParinte pp= new Parinte ();\nParinte pc= new Copil ();\nCopil cc= new Copil ();\n//    Copil cp= new Parinte ();  // Parinte cannot be converted to Copil\npp.afis (\"pp 1\");\npc.afis (\"pc 2\");\ncc.afis (\"cc 3\");\n}\n}Ce se afișează  ?\nRezultatul afișării\npackage adnotare ;\npublic class TestParinteCopil {\npublic static void main(String [] args ) { \nParinte pp= new Parinte ();\nParinte pc= new Copil ();\nCopil cc= new Copil ();\n//    Copil cp= new Parinte ();  //Parinte cannot be converted to Copil\npp.afis (\"pp 1\");\npc.afis (\"pc 2\");\ncc.afis (\"cc 3\");\n}\n}Afis parinte : pp 1\nAfis parinte : pc 2\nAfis copil : cc 3\nFie o nouă metodă în clasa Copil\npackage adnotare ;\npublic class Copil extends Parinte {\n@Override\npublic void afis(String sir){\nSystem .out.println (\"Afis copil : \" + sir);\n}\npublic void scrie (String sir){\nSystem .out.println („Scrie copil : \" + sir);\n}",
    "lic class Copil extends Parinte {\n@Override\npublic void afis(String sir){\nSystem .out.println (\"Afis copil : \" + sir);\n}\npublic void scrie (String sir){\nSystem .out.println („Scrie copil : \" + sir);\n}\n}\nCe se afișează ?\npackage adnotare ;\npublic class TestParinteCopil {\npublic static void main (String [] args) {\nParinte pp = new Parinte ();\nCopil cc = new Copil ();\nParinte pc = new Copil ();\n//      Copil cp= new Parinte ();     \n// err: Parinte cannot be converted to Copil\npp.afis(\"pp 1\" );\ncc.afis(\"cc 3\" );\ncc.scrie (\"pc 3.2\" );\npc.afis(\"pc 2\" );\n// pc. scrie (\"pc 2\");   -> eroare -necesar cast\n((Copil )pc).scrie (\"pc 2\" );\n}\n}\nCe se afișează ?\npackage adnotare ;\npublic class TestParinteCopil {\npublic static void main (String [] args) {\nParinte pp = new Parinte ();\nCopil cc = new Copil ();\nParinte pc = new Copil ();\n//      Copil cp= new Parinte ();     \n// err: Parinte cannot be converted to Copil\npp.afis(\"pp 1\" );\ncc.afis(\"cc 3\" );\ncc.scrie (\"pc 3.2\" );\npc.afis(\"pc 2\" );\n// pc.",
    "il ();\nParinte pc = new Copil ();\n//      Copil cp= new Parinte ();     \n// err: Parinte cannot be converted to Copil\npp.afis(\"pp 1\" );\ncc.afis(\"cc 3\" );\ncc.scrie (\"pc 3.2\" );\npc.afis(\"pc 2\" );\n// pc. scrie (\"pc 2\");   -> eroare -necesar cast\n((Copil )pc).scrie (\"pc 2\" );\n}\n}\nAfis parinte : pp 1\nAfis copil : cc 3\nScrie copil : pc 3.2\nAfis copil : pc 2\nScrie copil : pc 2\nClasăabstract ă\npublic abstract class FiguraGeometrica {\npublic abstract double getAria ();\n}\npublic class Cerc extends FiguraGeometrica {\ndouble r;\npublic Cerc (double r){\nthis.r =r;\n}\npublic double getAria () { \nreturn Math.PI *r*r; \n}\n}\nClasa abstracta\npublic class Dreptunghi extends FiguraGeometrica {\ndouble lat, lung ;\npublic Dreptunghi(double lat, double lung ){\nthis.lat =lat;\nthis.lung=lung ;\n}\npublic double getAria () { \nreturn lung*lat ; \n}\n}\nMostenire\npublic class Patrat extends Dreptunghi {\npublic Patrat (double lat){\nsuper( lat, lat);\n}\n}\nClasa abstracta\npublic class AriaTotala {\npublic static double sumaAri",
    "() { \nreturn lung*lat ; \n}\n}\nMostenire\npublic class Patrat extends Dreptunghi {\npublic Patrat (double lat){\nsuper( lat, lat);\n}\n}\nClasa abstracta\npublic class AriaTotala {\npublic static double sumaAriilor (FiguraGeometrica figuri []) {\ndouble suma =0;\nfor (FiguraGeometrica fig: figuri ) suma += fig.getAria ();\nreturn suma ;\n}\npublic static void main(String args[]){\nFiguraGeometrica diverse[] ={new Patrat (2), new Cerc (1),\nnew Dreptunghi (3, 4)  };\nSystem.out.println (\"Suma ariilor este \" + sumaAriilor (diverse ));\n}\n}\nInterfețe\npublic interface FigGeometrica {\npublic abstract double getAria ();\n}\npublic class Cerc implement sFigGeometrica {\ndouble r;\npublic Cerc (double r){\nthis.r =r;\n}\npublic double getAria () { \nreturn Math.PI *r*r; \n}\n}\nInterfețe\npublic class Dreptunghi implements FigGeometrica {\ndouble lat, lung ;\npublic Dreptunghi(double lat, double lung ){\nthis.lat =lat;\nthis.lung=lung ;\n}\npublic double getAria () { \nreturn lung*lat ; \n}\n}\nInterfețe\npublic class Patrat extends D",
    "eometrica {\ndouble lat, lung ;\npublic Dreptunghi(double lat, double lung ){\nthis.lat =lat;\nthis.lung=lung ;\n}\npublic double getAria () { \nreturn lung*lat ; \n}\n}\nInterfețe\npublic class Patrat extends Dreptunghi {\npublic Patrat (double lat){\nsuper( lat, lat);\n}\n}\nNemodificat\nInterfețe\npublic class AriaTotala {\npublic static double sumaAriilor (FigGeometrica figuri []) {\ndouble suma =0;\nfor (FigGeometrica fig: figuri ) suma += fig.getAria ();\nreturn suma ;\n}\npublic static void main(String args[]){\nFigGeometrica diverse[] ={new Patrat (2), new Cerc (1),\nnew Dreptunghi (3, 4)  };\nSystem.out.println (\"Suma ariilor este \" + sumaAriilor (diverse ));\n}\n} Nemodificat\nInterf ețe\nSunt utile pentru :\n•A modela similaritățile dintre clase între \ncare nu există o relație de moștenire . \n•Declar area metodelor care există cu \ncertitudine într -o clasă (sau mai multe).\n•A putea lucra cu un obiect de programare \nfără a -i cunoaște clasa (doar interfața).\nInter fețele\n•Similare cu ” abstract class”\n•Ajut",
    "delor care există cu \ncertitudine într -o clasă (sau mai multe).\n•A putea lucra cu un obiect de programare \nfără a -i cunoaște clasa (doar interfața).\nInter fețele\n•Similare cu ” abstract class”\n•Ajută la a pune în evidență metodele comune în \nclase diferite\n•Toate metodele sunt public\n•În Java o clasă poate implementa mai multe \ninterfețe .\nInterf ețe\ninterface SouthParkCharacter {\nvoid curse();\n}interface IChef {\nvoid cook(Food food);\n}\ninterface BabyKicker {\nvoid kickTheBaby(Baby);\n}\nclass Chef implements IChef, SouthParkCharacter {\n// overridden methods MUST be public\n// can you tell why ?\npublic void curse() { … }\npublic void cook(Food f) { … }\n}\n* access rights (Java forbids reducing of access rights)\nCând e necesară o interfață ?\nAtunci când se dorește ascunderea \nstructurii interne a unei clase. \nNumai interfața este făcută cunoscută.",
    "a unei clase. \nNumai interfața este făcută cunoscută.",
    "class Creion {\npublic Creion () {\nSystem .out.println (\"Creion ()\");\nscrie ();\n}\npublic void scrie (){\nSystem .out.println (\"HB\" );\n}\n}\nclass CreionColorat extends Creion {\nprivate String culoare ;\npublic CreionColorat (String culoare ) {\nSystem .out.println (\"CreionColorat ()\");\nthis.culoare = culoare ;\nscrie ();\n}\n@Override\npublic void scrie () {\nSystem .out.println (culoare );\n}\n}\npublic class Main {\npublic static void main (String [] args) {\nCreionColorat crosu = new CreionColorat (\"rosie \");\n}\n}Recapitulare mo ștenire\nCe se afisează?\nclass Creion {\npublic Creion () {\nSystem .out.println (\"Creion ()\");\nscrie ();\n}\npublic void scrie (){\nSystem .out.println (\"HB\" );\n}\n}\nclass CreionColorat extends Creion {\nprivate String culoare ;\npublic CreionColorat (String culoare ) {\nSystem .out.println (\"CreionColorat ()\");\nthis.culoare = culoare ;\nscrie ();\n}\n@Override\npublic void scrie () {\nSystem .out.println (culoare );\n}\n}\npublic class Main {\npublic static void main (String [] args) {\nCrei",
    "ntln (\"CreionColorat ()\");\nthis.culoare = culoare ;\nscrie ();\n}\n@Override\npublic void scrie () {\nSystem .out.println (culoare );\n}\n}\npublic class Main {\npublic static void main (String [] args) {\nCreionColorat crosu = new CreionColorat (\"rosie \");\n}\n}Recapitulare mo ștenire\nCe se afisează?\nCreion ()\nnull\nCreionColorat ()\nrosie\n\n\nMotorElectric jucarie = new MotorElectric ();\nAspirator a = new Aspirator( 500);\nVentilator v = new Ventilator( 200);\nElectroCasnice [] aparate = new ElectroCasnice [] { a, v};\ndouble costTotal =0;\nfor(ElectroCasnice apcrt : aparate )\ncostTotal += apcrt .getPret ();\nSystem .out.println (costTotal );\nMotor [] motoare = new Motor[] { jucarie , a, v};\nfor (Motor mcrt : motoare ) \nmcrt .start ();700.0\nME Start\nAspirator pornit\nVentilator pornit\npackage ro.usv ;\npublic interface Motor {\nvoid start ();\nvoid stop ();\n}\npackage ro.usv ;\npublic class MotorElectric implements \nMotor {\n@Override\npublic void start () {\nSystem .out.println (\"ME Start\" );\n}\n@Override\npublic",
    "interface Motor {\nvoid start ();\nvoid stop ();\n}\npackage ro.usv ;\npublic class MotorElectric implements \nMotor {\n@Override\npublic void start () {\nSystem .out.println (\"ME Start\" );\n}\n@Override\npublic void stop () {\nSystem .out.println (\"ME Stop\" );\n}\n}package ro.usv ;\npublic class ElectroCasnice {\nprivate double pret;\npublic ElectroCasnice (double pret) {\nthis.pret = pret;\n}\npublic double getPret () {\nreturn pret;\n}\npublic void setPret (double pret) {\nthis.pret = pret;\n}\n@Override\npublic String toString () {\nreturn getClass ().getSimpleName () +  \"  pret=\" + pret;\n}\n}\npackage ro.usv ;\npublic class Aspirator extends ElectroCasnice\nimplements Motor {\n//cese intampla daca nu arfi implements Motor?\npublic Aspirator (double pret) {\nsuper (pret);\n}\n@Override\npublic void start () {\nSystem .out.println (\"Aspirator pornit \");\n}\n@Override\npublic void stop () {\nSystem .out.println (\"Aspirator oprit \");\n}\n}package ro.usv ;\npublic class Ventilator extends ElectroCasnice\nimplements Motor {\npublic Ve",
    "intln (\"Aspirator pornit \");\n}\n@Override\npublic void stop () {\nSystem .out.println (\"Aspirator oprit \");\n}\n}package ro.usv ;\npublic class Ventilator extends ElectroCasnice\nimplements Motor {\npublic Ventilator (double pret) {\nsuper (pret);\n}\n@Override\npublic void start () {\nSystem .out.println (\"Ventilator pornit \");\n}\n@Override\npublic void stop () {\nSystem .out.println (\"Ventilator oprit \");\n}\n}\n\nInteger obj1 = new Integer( 10);\nInteger obj2 = new Integer( 10);\nSystem .out.println (\"obj1==obj2 ->\"+(obj1 ==obj2 ));\nSystem .out.println (\"obj1.equals(obj2) ->\"+ obj1 .equals( obj2 ));\nobj1==obj2 ->false\nobj1.equals(obj2) ->true\ns = \" cde\";\nString s = \"abc\";  // String s = new String(\" abc\");\nString s0 =s;\ns = \"cde\";\nSystem .out.println (\"s=\"+s+\" s0=\" +s0 );\ns=cdes0=abc\nString s0 = \"abc\";   \nString sx=\"Abc\";\nSystem .out.println (\"s0=“ + s0  + \"  sx=\"+sx);\nSystem .out.println (\"s0== sx->“ + (s0==sx) );\nSystem .out.println (\"s0.equalsIgnoreCase( sx) ->“ + \ns0.equalsIgnoreCase( sx) );\nSystem .",
    "ring sx=\"Abc\";\nSystem .out.println (\"s0=“ + s0  + \"  sx=\"+sx);\nSystem .out.println (\"s0== sx->“ + (s0==sx) );\nSystem .out.println (\"s0.equalsIgnoreCase( sx) ->“ + \ns0.equalsIgnoreCase( sx) );\nSystem .out.println (\"s0.equals( sx) ->“ + s0.equals( sx) );\nSystem .out.println (\"s0.compareTo( sx) ->“ + s0.compareTo( sx) );\nSystem .out.println (\"s0.equals( sx.toLowerCase ()) ->“ + \ns0.equals ( sx.toLowerCase () ) );\nSystem .out.println (\"sx=“ + sx);\n//toLowerCase () nu modifica sirul\ns0=abcsx=Abc\ns0==sx->false\ns0.equalsIgnoreCase( sx) ->true\ns0.equals( sx) ->false\ns0.compareTo( sx) ->32\ns0.equals( sx.toLowerCase ()) ->true\nsx=Abc\nString s1 = \"FIESC\" ;\nString s2 = \"FIESC\" ; // nu se creeaza un obiect nou, caci\n// exista deja un sir \"FIESC“; de aceea s2 vaavea\n// aceeasi valoare ca s1 ( referinte egale )\n// Acesta este siunul din mtivele pt. care \n/ /sirurile sunt imutabile .\n// JVM este apreciata ca o \"masterpiece\" !\nString s3 =\"USV\" ;\nSystem .out.println (\"s1=\" +s1+ \", s2=\" +s2+ \", s3=\" +s3)",
    "egale )\n// Acesta este siunul din mtivele pt. care \n/ /sirurile sunt imutabile .\n// JVM este apreciata ca o \"masterpiece\" !\nString s3 =\"USV\" ;\nSystem .out.println (\"s1=\" +s1+ \", s2=\" +s2+ \", s3=\" +s3);\nSystem .out.println (\"s1==s2 ->\"+(s1==s2) + \", s1.equals(s2) ->\"+\ns1.equals( s2));\nSystem .out.println (\"s1==s3 ->\"+(s1==s3) + \", s1.equals(s3) ->\"+\ns1.equals( s3));// firesc\ns1=FIESC, s2=FIESC, s3=USV\ns1==s2 ->true, s1.equals(s2) ->true\ns1==s3 ->false, s1.equals(s3) ->false",
    "Java Collections Framework  \nMaterialul folosește  \nThe Java™ Tutorials  \nhttps://docs.oracle.com/javase/tutorial/collections/TOC.html  \nși \nSlides by Donald W. Smith  \nTechNeTrain.com  \n \n Collection  \nCollection = un container  \nUn obiect  care grupeaz ă mai multe obiecte într -\no singură unitate.  \nÎn mod obișnuit o colecție este formată din \nelemente care pot forma un grup în mod natural \n(un set de cărți, emailurile primite, trimise, \nnumerele de telefon ale prietenilor).  \n \nJava Collections Framework  \nO arhitectură unificată pentru a reprezenta și \nprelucra colecțiile.  \nConține:  \n•Interfețe  \n•Implementări (structuri de date reutilizabile)  \n•Algoritmi – metode ce realizează căutarea, \nsortarea elementelor colecții; algoritmii sunt \npolimorfici  \nCollection - Interfețe  \nToate interfețele sunt generice  \npublic interface Collection<E>...  \nCollection  Nu are o implementare  directă  în JDK.",
    "elementelor colecții; algoritmii sunt \npolimorfici  \nCollection - Interfețe  \nToate interfețele sunt generice  \npublic interface Collection<E>...  \nCollection  Nu are o implementare  directă  în JDK. Reprezintă  cel mai general  tip \nde colecţie  fiind  utilizat  în special  pentru  transferul  colecţiilor  ca \nargumente  ale unor  metode . \nList o colecţie  secvenţială  în care  elementele  sunt  ordonate  după  \nindecşi . Se admit  duplicate  ale elementelor,  stocarea  şi regăsirea  lor \nfiind  posibilă  datorită  indecşilor  (similar  cu clasa  Vector ).   \nSet implementează  o mulţime  (o colecţie  care  conţine  numai  elemente  \nunice)  \nSortedSet   un obiect  set care  garantează  traversarea  de către  iteratorul  propriu  \nîn ordinea  crescătoare  a elementelor . Sortarea  va fi făcută  conform  \nordinii  naturale  a cheilor  (pe baza  interfeţii  Comparable  din \njava.lang)  sau a unui  comparator  furnizat  ca argument  \nconstructorului .",
    "re  a elementelor . Sortarea  va fi făcută  conform  \nordinii  naturale  a cheilor  (pe baza  interfeţii  Comparable  din \njava.lang)  sau a unui  comparator  furnizat  ca argument  \nconstructorului . \nMap reprezintă  un obiect  care  stochează  perechi  (cheie,  valoare) . \nMulţimea  cheilor  nu poate  conţine  duplicate,  o cheie  fiind  asociată  \ncel mult  unei  valori . \nSortedMap  un obiect  map  care  garantează  că elementele  vor fi menţinute  în \nordinea  crescătoare  a cheilor . Sortarea  va fi făcută  conform  ordinii  \nnaturale  a cheilor  (pe baza  interfeţii  Comparable  din java.lang)  sau a \nunui  comparator  furnizat  ca argument  constructorului . \nQueue  Reprezintă  o coadă ; accesul  poate  fi FIFO  dacă este o coadă  simplă,  \nsau pe baza unui comparator  al priorităților  dacă este o PriorityQueue  \nDeque  o structură  abstractă  care  permite  inserările  și eliminările  la ambele  \ncapete ; accesul  poate  fi FIFO  sau LIFO ; o structură  mai bogată  decît  \nco",
    "ilor  dacă este o PriorityQueue  \nDeque  o structură  abstractă  care  permite  inserările  și eliminările  la ambele  \ncapete ; accesul  poate  fi FIFO  sau LIFO ; o structură  mai bogată  decît  \ncoada  și stiva  deoarece  înglobează  funcționalitățile  pentru  Queue  și \nStack  în același  timp  \nIterator   \npublic interface  Iterator<E>  {  \n      boolean hasNext();  \n      E next();  \n      void remove() ; //optional   \n} \n \nfor-each  ascunde  iteratorul,  desi îl folosește  \nfor (Object o : collection)  \n         System.out.println(o); \nNu se poate  folosi  remove()  Collection  \nCollection  \nConstructorul de conversie  \nList<String > lista  =  new   ArrayList <> (c);  \n \nMetode ale interfeței Collection   \n•int size(),   \n•boolean  isEmpty (), \n•boolean  contains(Object e lement ),  \n•boolean  add(E element),   \n•boolean  remove(Object element),  \n•Iterator<E > iterator().  \n \nMetode ce operează  asupra întregii colecții  \n•boolean  containsAll (Collection<?> c),   \n•boolean  ad",
    "•boolean  add(E element),   \n•boolean  remove(Object element),  \n•Iterator<E > iterator().  \n \nMetode ce operează  asupra întregii colecții  \n•boolean  containsAll (Collection<?> c),   \n•boolean  addAll (Collection<? extends E> c),   \n•boolean  removeAll (Collection<?> c),   \n•boolean  retainAll (Collection<?> c),  \n•void clear (). \nMetode pentru operații cu vectori  \n• Object[] toArray ()  \n• <T> T[] toArray (T[] a ) \nIterator în Collection  \nstatic void filter(Collection<?> c) {  \n    for (Iterator<?> it = c.iterator (); it.hasNext (); ) \n        if (!cond (it.next ())) \n            it.remove (); \n} \nInterfața List  \n•O listă este o secvență ordonată  de elemente  \ninterface List<E> extends Collection, Iterable   \n•Metode  important e List: \n–void add( int index, E element)  \n–E remove( int index)  \n–boolean  remove(Object o)  \n–E set( int index, E element)  \n–E get( int index)  \n–int indexOf (Object o)  \n–int lastIndexOf (Object o)  \n–ListIterator <E> listIterator () \n•A ListItera",
    "( int index)  \n–boolean  remove(Object o)  \n–E set( int index, E element)  \n–E get( int index)  \n–int indexOf (Object o)  \n–int lastIndexOf (Object o)  \n–ListIterator <E> listIterator () \n•A ListIterator  este similar cu Iterator , în plus are metodele  hasPrevious  \nși previous  \nImplementări List \nArrayList  \nList<String> numeAn3 = new ArrayList<>(numeAn2);  \n \nLinkedList  \nLinkedList <String> numeAngajati  =...; \nListIterator <String> iter = \nnumeAngajati .listIterator () \n \n Iterator i \n•Imaginați -vă un pointer între 2 elemente = cursorul  \nTipul generic pentru listIterator  trebuie să \ncoincidă cu tipul generic al LinkedList  \niterator.next();  \niterator.add( “J”); \nListIterator<String> iter = myList.listIterator()  \nListDemo.java (1)  \n•Exemplifică  add,   remov e   și   print  \nCopyright © 2013 by John Wiley & \nSons.  All rights reserved.  Page 12 \n\nListDemo.java (2)  \nCopyright © 2013 by John Wiley & \nSons.",
    ")  \nListDemo.java (1)  \n•Exemplifică  add,   remov e   și   print  \nCopyright © 2013 by John Wiley & \nSons.  All rights reserved.  Page 12 \n\nListDemo.java (2)  \nCopyright © 2013 by John Wiley & \nSons.  All rights reserved.  Page 13 \n\nIndexul unui Iterator  \nhasPrevious()  și previous()  se referă la elementul de dinaintea \ncursorului  \nhasNext()  și next()  se referă la elementul de după cursor  \n \npublic int indexOf(E e) {  \n    for (ListIterator<E>    it = listIterator();   it.hasNext();    ) \n        if (e == null ? it.next()  == null : e.equals( it.next() )) \n            return it.previousIndex() ;   //s-a găsit elementul e  \n \n    return -1;  //element negăsit  \n} \nMetoda set() a unui Iterator  \n•set() – înlocuiește ultimul element returnat de next() \nsau previous()  \n \npublic static <E> void replace (List<E> lst, E val, E newVal ) { \n    for (ListIterator<E> it = lst.listIterator();  it.hasNext();  )  \n        if (val == null ?",
    "returnat de next() \nsau previous()  \n \npublic static <E> void replace (List<E> lst, E val, E newVal ) { \n    for (ListIterator<E> it = lst.listIterator();  it.hasNext();  )  \n        if (val == null ? it.next() == null : val.equals(it.next()))  \n            it.set( newVal ); \n} \nÎnlocuirea unui element cu o listă  \npublic static <E>  void replace (  \n               List<E> list, E val, List<? extends E> newVals)  { \n \n    for (ListIterator<E> it = list.listIterator(); it.hasNext(); ){  \n \n        if (val == null ? it.next() == null : val.equals(it.next()))  \n       { \n            it.remove();  \n            for (E e : newVals)  \n                it.add(e);  \n        } \n    } \n} \nInterschimbă și amestecă  \npublic static <E> void swap(List<E> a, int i, int j) {  \n    E tmp = a.get(i);  \n    a.set(i, a.get(j));  \n    a.set(j, tmp);  \n} \n \npublic static void shuffle(List<?> list, Random rnd) {  \n    for (int i = list.size(); i > 1; i --) \n        swap(list, i - 1, rnd.nextInt(i));  \n} \n \nUn",
    "set(i, a.get(j));  \n    a.set(j, tmp);  \n} \n \npublic static void shuffle(List<?> list, Random rnd) {  \n    for (int i = list.size(); i > 1; i --) \n        swap(list, i - 1, rnd.nextInt(i));  \n} \n \nUn algoritm polimorfic, fair (permutările se realizează de la sfârșit \ncătre început cu aceeași probabilitate)  și rapid (list.size() operații)  \nAmestecarea șirurilor din linia de c -dă \nimport java.util.*;  \n \npublic class Shuffle {  \n    public static void main(String[] args) {  \n      List<String> list = new ArrayList<String> (); \n        for (String a : args)  \n               list.add(a);  \n        Collections.shuffle( list, new Random());  \n        System.out.println( list); \n    } \n} \nMetoda Arrays.asList()  \nimport java.util.*;  \n  \npublic class Shuffle {  \n    public static void main(String[] args) {  \n        List<String> list = Arrays.asList(args);  \n        Collections.shuffle(list);  \n        System.out.println(list);  \n    } \n} \n \nArrays.asList(vector)  dă o vedere (view) a vect",
    "ing[] args) {  \n        List<String> list = Arrays.asList(args);  \n        Collections.shuffle(list);  \n        System.out.println(list);  \n    } \n} \n \nArrays.asList(vector)  dă o vedere (view) a vectorului.  \nAici shuflle folosește o  metodă implicită de randomizare.   \n \nSub-liste \nList subList (int fromIndex , int toIndex ) \nEste identică cu  \n \nfor (int i = fromIndex ; i < toIndex ; i++) { ... }  \n \nSub-liste \nlst.subList(fromIndex , toIndex).clear();  \n•Se elimină toate elementele din sublistă de la indicele fromIndex inclusiv la \nindicele toIndex exclusiv   \nint i = lst.subList(fromIndex , toIndex). indexOf(ob);  \nint j = lst.subList(10, 20).lastIndexOf(ob);  \n \n•Sunt căutate doar în sub -listă nu și în listă  \n \nSub-liste \npublic static <E> List<E> dealHand(List<E> deck, int n) {  \n    int deckSize = deck.size();  \n    List<E> handView =  \n                               deck.subList(deckSize - n, deckSize);  \n    List<E> hand = new ArrayList<E>(handView);  \n    handView.clear();",
    "int deckSize = deck.size();  \n    List<E> handView =  \n                               deck.subList(deckSize - n, deckSize);  \n    List<E> hand = new ArrayList<E>(handView);  \n    handView.clear();  \n    return hand;  \n} \n \nEliminarea ultimelor elemente din ArrayList este mai rapidă decât eliminarea primelor \nelemente.  \nExemplu complet la \nhttps://docs.oracle.com/javase/tutorial/collections/interfaces/list.html  \n \nAlgoritmi din List  \n•sort — sorts a  List using a merge sort algorithm, which provides a fast, \nstable sort. (A  stable sort  is one that does not reorder equal elements.)  \n•shuffle  — randomly permutes the elements in a  List. \n•reverse  — reverses the order of the elements in a  List. \n•rotate  — rotates all the elements in a  List by a specified distance.  \n•swap  — swaps the elements at specified positions in a  List. \n•replaceAll  — replaces all occurrences of one specified value with another.",
    "ates all the elements in a  List by a specified distance.  \n•swap  — swaps the elements at specified positions in a  List. \n•replaceAll  — replaces all occurrences of one specified value with another.  \n•fill — overwrites every element in a  List with the specified value.  \n•copy  — copies the source  List into the destination  List. \n•binarySearch  — searches for an element in an ordered  List using the \nbinary search algorithm.  \n•indexOfSubList  — returns the index of the first sublist  of one  List that is \nequal to another.  \n•lastIndexOfSubList  — returns the index of the last sublist  of one  List that is \nequal to another.",
    "Structuri  de date în Java  \nJava Collections Framework  \nDeque , Iterator  \nThe core collection interfaces  \n\nCollection Interface  \n•Operatii  de baza   \n–int size();  \n–boolean  isEmpty ();  \n–boolean  contains(Object element);  \n–boolean  add(E element);  \n–boolean  remove(Object element);  \n–Iterator iterator();  \n•Operatii  cu colectii  \n–boolean  containsAll (Collection<?> c);  \n–boolean  addAll (Collection<? extends E> c);  \n–boolean  removeAll (Collection<?> c);  \n–boolean  retainAll (Collection<?> c);  \n–void clear();  \n•Operatii  cu vectori  \n–Object[] toArray (); <T> T[] toArray (T[] a); }  \nGeneral Purpose Implementations  \nCollection  \nSet List Queue  \nSortedSet  Map  \nSorted Map  \nHashSet  HashMap  \nList<String> list1 = new ArrayList<String>(c);  ArrayList  TreeSet  TreeMap  LinkedList  \nList<String> list2 = new LinkedList<String>(c);  \nDouble Ended Queue ( Deque ) \n\nDouble Ended Queue ( Deque ) \npublic interface Deque <E> {    // o descriere  de principiu  \nint size( );",
    "LinkedList  \nList<String> list2 = new LinkedList<String>(c);  \nDouble Ended Queue ( Deque ) \n\nDouble Ended Queue ( Deque ) \npublic interface Deque <E> {    // o descriere  de principiu  \nint size( );  \nboolean  isEmpty ( ); \nE getFirst ( ); \nE getLast ( ); \nvoid addFirst (E e);  \nvoid addLast (E e);  \nE removeFirst ( ); \nE removeLast ( ); \n} \nDouble Ended Queue ( Deque ) \nNoSuchElementExcepton     (getFirst (), getLast (), removeFirst (), removeLast () ) \nnull  (peekFirst (), peekLast (),   pollFirst (), pollLast () )                                    \nImplement ări:   java.util.ArrayDeque  \njava.util.LinkedList  \nDeque  dequeA = new LinkedList (); \n \ndequeA.add(\"e0\");   // la urma ;  dequeA = (e0) \ndequeA.add Last(\"e1\");   //       dequeA = (e0,e1)  \ndequeA.add First (\"e2\");   //       dequeA = ( e2 e0 e1 ) \n \nIterator  iterator = dequeA.iterator();  \nwhile(iterator.hasNext(){  \n  String element = (String) iterator.next();  \n} \n \nfor(Object object : dequeA) {  \n    String element =",
    "dequeA = ( e2 e0 e1 ) \n \nIterator  iterator = dequeA.iterator();  \nwhile(iterator.hasNext(){  \n  String element = (String) iterator.next();  \n} \n \nfor(Object object : dequeA) {  \n    String element = (String) object;  \n} \nObject p = dequeA.removeFirst(); // p=e2,  dequeA = ( e0 e1 )  \nObject u = dequeA.removeLast (); // u=e1 ,  dequeA = ( e0 ) \nCe afiseaza     System.out.println (deque  +”\\n”);      ? \n[Element 6 (Head), Element 4 (Head), Element 2 (Head), Element 1 (Tail), Element 3 (Tail), \nElement 5 (Tail), Element 7 ( Tail) ] \nCe afiseaza  Iterator -ul standard si ‘descending’ ?  \n\n\nBibliografie  \nhttps://examples.javacodegeeks.com/core -java/util/deque -util/java -util-\ndeque -example / \nhttp:// tutorials.jenkov.com/java -collections/deque.html#implementations",
    "Expresii Lambda\nJava 8\nExpresii Lamda (->   este operatorul Lambda )\n(intx, inty) -> x+y\ndouble f( intx, inty) { \nreturn x+y;\n}(parametri) -> expres ie (parametri) -> { instructiuni }\n(x) -> { System.out.print (x); }\nvoid afis(Object x) {\nSystem.out.print (x); \n}\nPrecizarea tipului argumentelor poate lipsi daca acesta poate fi dedus din comtext (inferat ).\nParantezele pot lipsi daca este vorba de un singur parametru . Ex. a-> a+1\nInterfe țe funcționale\nSunt interțele care au o singură metodă abstractă\nExemple:\njava.lang.Runnable -run()\njava.util.Comparator -compare(T o1, T o2)\njava.awt.event.ActionListener -\nactionPerformed (ActionEvent e)\nExemplu\npublic class TestDiverse implements ActionListener {\npublic static void main(String[] args) {  \n//...\nButton b=new Button(\"Stop\");\nb.addActionListener( this );\n//...\n}\n@Override\npublic void actionPerformed(ActionEvent e) {\nSystem.exit(0);\n}\n} \nExpresii Lamda\nButton b=new Button(\"Stop\");\nActionListener  ob = (e) -> {System.exit(0); }  ;\nb.addA",
    "stener( this );\n//...\n}\n@Override\npublic void actionPerformed(ActionEvent e) {\nSystem.exit(0);\n}\n} \nExpresii Lamda\nButton b=new Button(\"Stop\");\nActionListener  ob = (e) -> {System.exit(0); }  ;\nb.addActionListener( ob);\nsau\nButton b=new Button(\"Stop\");\nb.addActionListener (  (e)->{System.exit(0);} );\nExpresii Lamda siinterfete functionale\ninterface Numar {\npublic int valoare(int n);\n}\npublic class Exemplu {\npublic static void main(String[] args) {\nNumar nr;\nnr = n-> n<0? 0:n ;\nSystem.out.println(\"N1=\" + nr.valoare( -1));\nSystem.out.println(\"N2=\" + nr.valoare(2) );\nnr = (n)-> n*n ;\nSystem.out.println(\"N3=\" + nr.valoare(3) );N1=0\nN2=2\nN3=9\nExpresii Lamda siinterfete functionale\nnew Thread (new Runnable () \n{\n@Override\npublic void run() {\nwhile(true) {\nasteapta (1000);\nSystem.out.print (\"*\");\n}\n}\n}\n).start();new Thread (() -> {\nwhile(true) {\nasteapta (1000);\nSystem.out.print (\"*\");\n}\n} \n).start();\nExpresii Lamda siinterfete functionale\ninterface Functie {\nlong  f(int n);\n}\n//…\nFunctie fac",
    "}\n}\n}\n).start();new Thread (() -> {\nwhile(true) {\nasteapta (1000);\nSystem.out.print (\"*\");\n}\n} \n).start();\nExpresii Lamda siinterfete functionale\ninterface Functie {\nlong  f(int n);\n}\n//…\nFunctie factorial = (n) -> {\nlong rez= 1;\nfor(int i=2; i <= n; i++)\nrez*= i;\nreturn re z;\n};\nintm=7;\nSystem.out.println ( m + \"!=\" + factorial.f (m) );\nExpresii Lamda\n() -> 9.5                     public double f() { return 9.5;}\n(n) -> (n % 2)== 0 public boolean g(intn){ return (n % 2)==0 ;}\nCare expresii sunt corecte ?\n() -> {}\n() -> \"Radu\"\n() -> Math.random() * 100\n() -> {return \" Mari a\";}\n(Integer i) -> return \" Alex\" + i;\n(String s) -> {\"Student \";}\nFunctie calcul1 = () ->1;\nFunctie calcul2 = x ->x+2; \nFunctie calcul3 = x ->3;\nFunctie calcul4 = (x) ->\"4\";interface Functie {\nlong f(int n);\n}\nExpresii Lamda\n() -> 9.5                     public double f() { return 9.5;}\n(n) -> (n % 2)== 0 public boolean g(intn){ return (n % 2)==0 ;}\nCare expresii sunt corecte ?\n() -> {}\n() -> \"Radu\"\n() -> Math.ran",
    "i Lamda\n() -> 9.5                     public double f() { return 9.5;}\n(n) -> (n % 2)== 0 public boolean g(intn){ return (n % 2)==0 ;}\nCare expresii sunt corecte ?\n() -> {}\n() -> \"Radu\"\n() -> Math.random() * 100\n() -> {return \" Mari a\";}\n(Integer i) -> return \" Alex\" + i;\n(String s) -> {\"Student\";}\nFunctie calcul1 = () ->1;\nFunctie calcul2 = x ->x+2; \nFunctie calcul3 = x ->3;\nFunctie calcul4 = (x) ->\"4\";interface Functie {\nlong f(int n);\n}\nExpresii Lamda\n() -> 9.5                     public double f() { return 9.5;}\n(n) -> (n % 2)== 0 public boolean g(intn){ return (n % 2)==0 ;}\nCare expresii sunt corecte ?\n() -> {}\n() -> \"Radu\"\n() -> Math.random() * 100\n() -> {return \" Mari a\";}\n(Integer i) -> {return \"Alex\" + i;}\n(String s) -> \"Student \"sau (String s) -> {return \"Student \";}\nFunctie calcul1 = ( v)->1; \nFunctie calcul2 = x ->x+2; \nFunctie calcul3 = x ->3;\nFunctie calcul4 = (x) ->4; //\"4“;interface Functie {\nlong f(int n);\n}\nReferirea metodelor\nnumeClasa :: numeMetoda\nSe aplic ă pentru",
    "ul1 = ( v)->1; \nFunctie calcul2 = x ->x+2; \nFunctie calcul3 = x ->3;\nFunctie calcul4 = (x) ->4; //\"4“;interface Functie {\nlong f(int n);\n}\nReferirea metodelor\nnumeClasa :: numeMetoda\nSe aplic ă pentru obținerea unei referințe dacă \nmetoda este\n-statică\n-de instanță\nthis :: numeMetoda\nReferința către constructor\nnumeClasa :: new\nReferirea metodelor\npublic interface FileFilter {\npublic boolean accept(Filepathname) ;\n}\nIn clasa File:\npublicFile[]listFiles (FileFilter filter) \npublic boolean isDirectory ()\nAfisarea subdirectoarelor (Java 7)\nFile dir=new File(\"D: \\\\SD\");\nFile[] subDir = dir.listFiles ( new FileFilter() {\n@Override\npublic boolean accept(File f){\nreturn f.isDirectory();\n}\n} \n);\nfor(File f: subDir)\nSystem.out.println(f);\nAfisarea subdirectoarelor (Java 8)\nFile dir=new File(\"D: \\\\SD\");\nFile[] subDir = dir.listFiles ( f -> f.isDirectory ());\nfor(File f: subDir)\nSystem.out.println(f);\nExpresie Lambda\nAfisarea subdirectoarelor (Java 8)\nFile dir=new File(\"D: \\\\SD\");\nFile[] subDir =",
    "D\");\nFile[] subDir = dir.listFiles ( f -> f.isDirectory ());\nfor(File f: subDir)\nSystem.out.println(f);\nExpresie Lambda\nAfisarea subdirectoarelor (Java 8)\nFile dir=new File(\"D: \\\\SD\");\nFile[] subDir = dir.listFiles ( File :: isDirectory );\nfor(File f: subDir)\nSystem.out.println(f);\nReferirea metodelor\nExpresiile Lambda\n•Oexpresie lambda –o funcție anonimă\n•Sintaxa e xpresiile lambda :\n(arg) -> expresie sau (arg)-> { instructiuni }\n•Expresiile lambda permit scrierea de cod concis\n•O interfață functional ăeste o interfață care declară o \nsingură metodă abstractă\n•Expresiile lambda sunt utilizate în contextul interfețelor \nfuncționale\n•Referirea metodelor o alternativa la Expresiile lambda\ncare pot fi reutilizate\nBibliografie\n•Java 8 Lambdas , by Richard \nWarburton , Published by O’Reilly \nMedia, 2014\n•Java 8 in Action , by Raoul -Gabriel \nUrma , Mario Fusco , Alan Mycroft , 2014 \nManning Publications\n•Building Java Programs , Chapter 19, \nPearson 2016",
    "dia, 2014\n•Java 8 in Action , by Raoul -Gabriel \nUrma , Mario Fusco , Alan Mycroft , 2014 \nManning Publications\n•Building Java Programs , Chapter 19, \nPearson 2016",
    "Java 9  \nWhat’s New in Oracle JDK 9. Release 9. E77563 -05 \nSeptember 2017  \n \nhttps://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNE\nW-GUID -825576B5 -203C -4C8D -85E5 -FFDA4CA0B346  \n \n \nNoi caracteristici  in Java 9  \n•Factory Methods for Immutable List, Set, Map and Map.Entry  \n•Try With Resources Improvement  \n•Private methods in Interfaces  \n•Java 9 Module System  \n•Java 9 REPL (JShell)  \n•Diamond Operator for Anonymous Inner Class  \n•Optional Class Improvements  \n•Reactive Streams  \n•Stream API Improvements  \n•Process API Improvements  \n•Enhanced @Deprecated annotation  \n•HTTP 2 Client  \n•Мulti-Resolution Image API  \nJava 9  \nFactory Methods  \nfor Immutable  \nList, Set, Map, Map.Entry  \n \nCrearea  unei  liste IMUTABILE in Java 8 \nsi in Java 9:  \nList<Punct> lista = new ArrayList<>  ();  \nlista.add  ( new Punct(1, 1)  );  \nlista.add  ( new Punct(2, 2)  );  \nlista.add  ( new Punct(3, 3)  );  \nlista.add  ( new Punct(4, 4)  );  \nlista = Collections.",
    "t<Punct> lista = new ArrayList<>  ();  \nlista.add  ( new Punct(1, 1)  );  \nlista.add  ( new Punct(2, 2)  );  \nlista.add  ( new Punct(3, 3)  );  \nlista.add  ( new Punct(4, 4)  );  \nlista = Collections. unmodifiableList  ( lista ); \nList< Punct > lista  = List.of   ( new Punct (1, 1),  \n                      new Punct (2, 2), new Punct (3, 3),  \n                      new Punct (4, 4)  );  \nIn Java 9:  \n•List immutableList  = List.of (); \n•List immutableList  = \nList.of (\"one\",\"two\",\"three \"); \n•Map dict = Map.of (); \n•Map.Entry  me = Map. ofEntries (); \nMetoda  of() \nstatic <E> List<E> of(E e1 ); \nstatic <E> List<E> of(E e1,E e2 ); \nstatic <E> List<E> of(E e1,E e2,E e3 ); \n. . .  s.a.m.d  \nstatic <E> List<E> of(E e1,E e2,E e3,E e4,E e5 , \n                                     E e6,E e7,E e8,E e9,E e10 ); \nstatic <E> List<E> of(E... elements ); \n \nCaracteristici  Colectii  imutable  \n•Elementele  nu pot fi adaugate , modificate  sau \neliminate  \n•Nu pot cntine  elementul  null \n•Exceptii",
    "e9,E e10 ); \nstatic <E> List<E> of(E... elements ); \n \nCaracteristici  Colectii  imutable  \n•Elementele  nu pot fi adaugate , modificate  sau \neliminate  \n•Nu pot cntine  elementul  null \n•Exceptii  daca  se incearca   \n \nObservatie . Nu sunt  permise  schimbari  la nivel  structural al \ncolectiilor  (ex. o lista de Studenti , studentul  2 nu poate  fi \nupdate ( inlocuit  cu un alt student), in schimb  putem  apela  \nsetter -ii Student; efectiv  referinta  2 nu poate  fi modificata ).. \nTry-with -resources  \nfinal Resource resource1 = new \nResource(\"resource1\");  \nResource resource2 = new \nResource(\"resource2\");  \ntry (Resource r1 = resource1; Resource r2 = \nresource2) { ... }  \n// Java SE 9  \ntry (resource1; resource2)  \n{ ... }  \n \n \nMetode  private in interfete  \nInterfete  in Java <= 7  \n•Constant variables  \n•Abstract methods  \n \nInterfete  in Java 8  \n•Constant variables  \n•Abstract methods  \n•Default methods  \n•Static methods  \n \nInterfete  in Java 9  \n•Constant variables  \n•Ab",
    "7  \n•Constant variables  \n•Abstract methods  \n \nInterfete  in Java 8  \n•Constant variables  \n•Abstract methods  \n•Default methods  \n•Static methods  \n \nInterfete  in Java 9  \n•Constant variables  \n•Abstract methods  \n•Default methods  \n•Static methods  \n•Private methods  \n•Private Static methods  \n \n\nDe ce ar fi nevoie  de metode  private  \n•Se evita  duplicatele  in scrierea  programelor  \n•Se expun  clientilor  doar  intentiile  de \nimplementare   \n \n \nJDK 9 Module System  \nJDK 9 Modules  \n•JDK fiind  prea  mare nu este  scalabil  \n(dezavantaj  dispozitive  mici) \n \n•Proiectul Jigsaw  \n\nJava 9 REPL ( JShell ) \n•Oracle Corp introduce un nou instrument \njshell  (Java Shell) numit  si REPL (Read Evaluate \nPrint Loop). Poate  fi folosit  la verificarea  \noricarei  secvente  Java (class , interface, enum , \nobiecte , instructiuni  etc). \n \njshell > int counter = 0  \ncounter ==> 0  \njshell > counter++  \n$6 ==> 0  \njshell > counter  \ncounter ==> 1  \nBIBLIOGRAFIE  \n•What’s New in Oracle JDK",
    "erface, enum , \nobiecte , instructiuni  etc). \n \njshell > int counter = 0  \ncounter ==> 0  \njshell > counter++  \n$6 ==> 0  \njshell > counter  \ncounter ==> 1  \nBIBLIOGRAFIE  \n•What’s New in Oracle JDK 9 , Release 9, E77563 -05, September \n2017, \nhttps://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW -\nGUID -C23AFD78 -C777 -460B -8ACE -58BE5EA681F6  \n•Nine New Developer Features in JDK 9, Simon \nRitter, https://www.oracle.com/corporate/features/jdk9 -new -\ndeveloper -features.html  \n•Java 9 Modules, Rambabu  Posa  , Oct. 2017 \nhttps://www.journaldev.com/13106/java -9-modules  \n•Java 9 Features with Examples , Rambabu  Posa  , Nov. 2017  \nhttps://www.journaldev.com/13121/java -9-features -with -\nexamples#factory -methods -immutable    \n•Java 9 Private methods in Interfaces , Rambabu  Posa  , Oct. 2017 \nhttps://www.journaldev.com/12850/java -9-private -methods -\ninterfaces",
    "Oct. 2017 \nhttps://www.journaldev.com/12850/java -9-private -methods -\ninterfaces",
    "Lucrarile de laborator nr. 10 si 11  \n \n \nARBORI BINARI  \nObiective  \n• Aprofundarea TDA arbore binar  \n• Utilizarea mai multor TDA pentru \nrealizarea programelor complexe  \n• Utilizarea interfetei grafice (JavaFX)  \n• programarea multi -thread  \n \n \nIn aceasta lucrare veti utiliza  \n• interfata grafica construita in lucrarea \nprecedenta pe care o veti dezvolta \nadaugand noi controale grafice si \nfunctionalitati butoanelor si optiunilor \ndin lista de selectie  \n• clasa ArboreBinar pe care o veti \ngeneraliza astfel incat sa accepte citirea \ndatelor  din interfata grafica si din fisier  \n• controlul FileChooser pentru a putea \ndeschide si salva fisiere prin interediul \nferestrelor de dialog Open si Save  \n  \n \nInterfata grafica  \n \nConstructia arborelui prin introducerea informatiei din noduri in campul de editar e \nIn imaginea de mai jos este redat momentul dupa introducerea radacinii (eticheta avea \nvaloarea „Radacina:”) si urmeaza introducerea fiului stang al radacinii.",
    "matiei din noduri in campul de editar e \nIn imaginea de mai jos este redat momentul dupa introducerea radacinii (eticheta avea \nvaloarea „Radacina:”) si urmeaza introducerea fiului stang al radacinii.  \n \n \n \nS-au introdus informatiile pentru un arbore cu 3 noduri (radacina „a”, iar „b”si „c”fiul st ang, \nrespectiv drept). Daca nu exista fiu se introduce un sir vid (se face click pe butonul OK). \nButonul Nod frunza trebuie sa simplifice dialogul. Astfel, l aintroducerea nodului b daca se \napasa pe Nod frunza si nu pe OK utilizatorul nu mai este intrebat care sunt fiii acestuia.  \n \n \n \nDupa ce s -au introdus toate nodurile eticheta se stege (dupa fiecare introducere a unui nod in \neticheta si in campul de editare se afiseaza sirul vid).  \n \nCitirea salvarea din/in fisier  \n \nPentru deschiderea unui fisier folositi Fi leChooser. Utilizati secventa de la adresa  \nhttps://docs.oracle.com/javase/8/javafx/api/javafx/stage/FileChooser.html  \nPentru Save exista functia showSaveDialog( mainSta",
    "erea unui fisier folositi Fi leChooser. Utilizati secventa de la adresa  \nhttps://docs.oracle.com/javase/8/javafx/api/javafx/stage/FileChooser.html  \nPentru Save exista functia showSaveDialog( mainSta ge) \nFunctia urmatoare deschide un fisier in citire (citire=true) sau in scriere (false).  \n \n    public  File deschideFisier(boolean citire) {  \n        FileChooser fileChooser = new FileChooser();  \n        fileChooser.setTitle(\"Open Resource File\");  \n        fileChooser.getExtensionFilters().addAll(  \n                new ExtensionFilter(\"Text Files\", \"*.txt\"),  \n                new ExtensionFilter(\"Arbori\", \"*.arb\"),  \n                new ExtensionFilter(\"All Files\", \"*.*\"));  \n        File selectedFile = citire? fileCho oser.showOpenDialog(mainStage)  \n                : fileChooser.showSaveDialog(mainStage);  \n        return selectedFile ;      \n    } \n \nDaca utilizatorul nu selecteaza un fisier functia returneaza null.",
    "r.showOpenDialog(mainStage)  \n                : fileChooser.showSaveDialog(mainStage);  \n        return selectedFile ;      \n    } \n \nDaca utilizatorul nu selecteaza un fisier functia returneaza null.  \n \n \nTrebuie sa continuati programarea citirii/salvarii arbor elui.  \n \n \nTEMA DE EFECTUAT IN LABORATORUL 10  \n1. Adaugati la interfata grafica realizata in laboratorul anterior cele 2 butoane „Citire \nfisier”, „Salvare in fisier”  \nPunctaj:  \n• 2p pentru aspect grafic ( butoane si separator vertical plus separator orizontal \nin Lis tView),  \n• 4p pentru citirea in TextArea  a unui fisier existent cu mai multe linii (ex. un \nfisier *,java – atentie trebuie pusa si extensia .java)  \n• 4p pentru salvarea unui fisier multilinie din TextArea  \n \n \nPentru Laboratorul 11 toti studentii trebuie sa aiba fu nctionale  \ninterfata grafica si citirea/salvarea unui fisier!  \n \n \n \nTema de efectuat in Laboratorul 11  \n \n1.",
    "r multilinie din TextArea  \n \n \nPentru Laboratorul 11 toti studentii trebuie sa aiba fu nctionale  \ninterfata grafica si citirea/salvarea unui fisier!  \n \n \n \nTema de efectuat in Laboratorul 11  \n \n1. Construi rea unui arbore  pe baza datelor citite  dintr -un fisier si efectuarea a cel putin 3 \ntraversari ale sale cu optiunile din ListView . Salvarea unui  arbore  intr-un fisier . Aceast a \noperati e nu inseamna copierea fisieru lui citit  pentru a construi arborele , ci parcurgerea \narborelui si salvarea informatiilor in fisier conform formatului din exemplul de mai jos . \nPunctaj :5p daca se efectue aza in lab.10, 2.5p pentru lab. 11 . \nPentru a se putea utiliza metoda constArbore() din clasa ArboreBinari  arborele \ntrebuie memorat  in fisier cu informatiile din noduri in inordine ( RSD ), iar acolo unde nu \nexista legatura la dreapta sau la stanga se va in dica un sir vid.  \nExemplu  de format de fisie r: \nArbore  Continut fisier  \n a \nb \nc \n \nd \n \ne \n \n \n \nImportant .",
    "nordine ( RSD ), iar acolo unde nu \nexista legatura la dreapta sau la stanga se va in dica un sir vid.  \nExemplu  de format de fisie r: \nArbore  Continut fisier  \n a \nb \nc \n \nd \n \ne \n \n \n \nImportant . Pentru test se vor utiliza 2 fisiere : cel prezentat mai sus si un fisier  \ncare va contin e descrierea arborelui reprezentand ex presia aritmetica \nurmatoare: (a-b)*(a+b)  \nIndicatie.  Scrieti o clasa  CitireNod uriDinFisier care sa implementeze \nCitireNod  si apelati constructorul  ArboreBinar(Citire Nod citnod)  utilizand o \ninstanta a acestei noi clase.  Pentru salvare a arborelui  adaugati clasei ArboreBinar \no metoda care sa parcurga arborele binar creat adaugand  un terminato r de linie  \npentru a obtine un fisier ca cel din exemplu . \n \n2. Programarea traversarii pe nivele (in latime): 2p  \nIndicatie . Algoritmul il gasiti in sectiunea 2. Algoritmi iterativi de traversare a \narborilor binari  din cadrul acestei lucrari de laborator.",
    "2. Programarea traversarii pe nivele (in latime): 2p  \nIndicatie . Algoritmul il gasiti in sectiunea 2. Algoritmi iterativi de traversare a \narborilor binari  din cadrul acestei lucrari de laborator.  \n3. Inlocuirea cozii utilizata in algoritmul de traversar e a arborelui pe nivele cu stiva si \nidentificarea traversarii ce se efectueaza astfel ( 0.5p). \n4. Progra mati evaluarea expresiilor aritmetice reprezentate prin arbori cititi din fisier \n(3p daca expresia contine numai constante si operatori binari, + 2p  daca ex presia \ncontine si  variabile a caror valoare este citita de la utilizator o singura data).  \nIndicatie . La sfarsitul acestei lucrari de laborator gasiti o Anexa cu programul \nPython  prezentat la cursul de PCLP II  (anul I) de evaluare a expresiilor \naritmetice  reprezentate sub forma de arbore. Expresiile contineau insa numai \nconstante. Pentru  variabile e necesara o structura suplimentara care sa stocheze \nperechile ( nume _variabila, valoare _variabila ).",
    "reprezentate sub forma de arbore. Expresiile contineau insa numai \nconstante. Pentru  variabile e necesara o structura suplimentara care sa stocheze \nperechile ( nume _variabila, valoare _variabila ). \n5. Citirea unui arbore , traversarea si salvarea sa in fisier nu mai cu operatii din interfata \ngrafica  (10p daca este realizata in lab. 10,  5p in lab.11). Dialogul a fost indicat la \ninceputul acestei lucrari.  \nIndicatie . Cititi exemplul Produca tor-Consumator din pagina cursului . \n \nPuteti utiliza urmatoarele 2 clase si interfata CitireNod.  \nClasa ArboreBinar  \npackage arbori;  \n \npublic class ArboreBinar {  \n  private Nod rad;  \n  CitireNod ci tnod;  \n  static String radacina=\"Radacina\";  \n  private String traversare;  \n \n    public ArboreBinar(CitireNod citnod) {  \n        this.citnod = citnod;  \n        rad = constArbore( creeazaNod(radacina, null) );  \n    } \n  \n   public ArboreBinar()  \n   { \n       citnod = new CitireNod(){};   // un obj.",
    "tireNod citnod) {  \n        this.citnod = citnod;  \n        rad = constArbore( creeazaNod(radacina, null) );  \n    } \n  \n   public ArboreBinar()  \n   { \n       citnod = new CitireNod(){};   // un obj. cu fctia. citesteInfo default  \n       rad = co nstArbore( creeazaNod(radacina, null) );  \n   } \n \n   public Nod constArbore (Nod x)  \n   { \n     if(((String)x.info()).equals(\"\")) return null;  \n     x.initStg( constArbore( creeazaNod(\" stang\",x) ));  \n     x.initDr( constArbore( creeazaNod(\"drept\",x) ));  \n     return x; \n    } \n \n   private Nod creeazaNod(String s,Nod tata)  \n   { \n      if(!s.equals(radacina))  \n               s=\"Fiul \"+ s + \" al nodului \"+ tata;  \n       \n      return new Nod( citn od.citesteInfo(s) );  \n   } \n \n   public String toString()  \n   { \n     traversare=\" Traversare SRD: \";  \n     SRD(rad);   \n     return traversare;  \n   }    \n \n   public void SRD(Nod x)  \n   { \n      if(x==null) return;  \n      SRD(x.stg());  \n      traversare += x.info() +\" \" ; \n      SRD",
    "sare SRD: \";  \n     SRD(rad);   \n     return traversare;  \n   }    \n \n   public void SRD(Nod x)  \n   { \n      if(x==null) return;  \n      SRD(x.stg());  \n      traversare += x.info() +\" \" ; \n      SRD(x.dr());  \n   } \n    public static void main(String[] args) {  \n        ArboreBinar a = new ArboreBinar();      \n        System.out.println(a);  \n    } \n} \n \n \n \nInterfata CitireNod  \npackage arbori;  \n \nimport java.io.BufferedReader;  \nimport java.io.InputStreamReader;  \n \npublic interface CitireNod {  \n    BufferedReader r = new BufferedReader( new InputStreamReader(System.in));  \n \n    public default String citesteInfo(String txt) {        \n        String info;  \n        System.out.print(txt + \":\");  \n         try { \n               info= r.readLine().trim();  \n         } catch(Exception e) {  \n               info=\"\";  \n               System.out.println(e);  \n         } \n         return info;  \n    } \n} \n \n \nClasa  Nod  \npackage arbori;  \n \nimport java.util.Objects;  \npublic class  Nod",
    "{  \n               info=\"\";  \n               System.out.println(e);  \n         } \n         return info;  \n    } \n} \n \n \nClasa  Nod  \npackage arbori;  \n \nimport java.util.Objects;  \npublic class  Nod {  \n \n   private Object info;  \n   private Nod stg=null, dr=nul l; \n// \n   public Nod(Object info) {  \n     this.info = info;  \n   }  \n   public void initStg(Nod stg)    {  \n       this.stg = stg;  \n   } \n   public void initDr(Nod dr)    {  \n       this.dr = dr;  \n   } \n   public Object info() { return info; }  \n   public Nod stg() {  return stg; }  \n   public Nod dr() { return dr; }  \n   public boolean esteFrunza() { return dr==null && stg==null; }  \n \n    @Override  \n    public int hashCode() {  \n        int hash = 7;  \n        hash = 89 * hash + Objects.hashCode(this.info);  \n        hash = 89 * h ash + Objects.hashCode(this.stg);  \n        hash = 89 * hash + Objects.hashCode(this.dr);  \n        return hash;  \n    } \n   public boolean equals (Object x) { return info.equals(x); }  \n   pu",
    "89 * h ash + Objects.hashCode(this.stg);  \n        hash = 89 * hash + Objects.hashCode(this.dr);  \n        return hash;  \n    } \n   public boolean equals (Object x) { return info.equals(x); }  \n   public String toString() { return info.toString();}  \n} \n \n \n2. Algoritmi iter ativi de traversare a arborilor binari  \n2.1. Traversarea în lăţime a arborilor binari  \nSe introduce în coadă nodul rădăcină şi apoi cît timp coada nu este vidă se execută \nurmătoarel e operaţii:  \n1)  se extrage un nod din coadă;     \n2) se vizitează acel nod;  \n3) se inserează în coadă  descendenţii săi (dacă îi are).  \nInserarea în coadă a descendenţilor trebuie făcută în ordinea vizitării lor. Deci mai întîi se va \ninsera fiul stîng apoi c el drept. Rezultă procedura travers_latime  în care F_ST[nod]  şi \nF_DR[nod]  desemnează fiul stîng şi drept al nodului nod. În procedura următoare se creează \nun obiect Coada, iar operaţiile cu acest obiect sunt reprezentate în stil Java,  \n \n       procedura  travers_lati",
    "d]  desemnează fiul stîng şi drept al nodului nod. În procedura următoare se creează \nun obiect Coada, iar operaţiile cu acest obiect sunt reprezentate în stil Java,  \n \n       procedura  travers_latime(a) este \n      | Q = new Coada ()  \n      | Q.add(Rădăcina_arborelui ) \n      |   cît timp  NOT Q.empty()  execută \n      | |     nod = Q.front()  \n      | |     Vizitează(nod)  \n      | |     Q.rem() \n      | |     dacă F_ST[nod]!=null atunci Q.add( F_ST [nod] )\n  \n      | |     dacă F_DR[nod]!=null atunci Q.add( F_DR [nod] )\n  \n      |   \n \n       sfîrşit \n \n2.2. Traversarea în preordine a arborilor binari  \nUtilizând acesastă procedură ca model şi înlocuind structura de coadă cu structura stivă, dar \ninversînd ord inea introducerii în structura de date a celor doi fii, obţinem algoritmul de  \ntraversare în pre -ordine (RSD) a unui arbore binar.  \n       procedura  RSD_iterativ (a) este \n      | S = new Stiva()  \n      | S.push (Rădăcina_arborelui)  \n      |   cît timp  NOT S.em pty()",
    "de  \ntraversare în pre -ordine (RSD) a unui arbore binar.  \n       procedura  RSD_iterativ (a) este \n      | S = new Stiva()  \n      | S.push (Rădăcina_arborelui)  \n      |   cît timp  NOT S.em pty()  execută \n      | |  nod = S.top()  \n      | |  Vizitează(nod)  \n      | |  S.pop() \n      | |  dacă F_DR[nod] !=null a tunci S.push( F_DR [nod] )\n  \n      | |  dacă F_ST[nod] !=null atunci S.push( F_ST [nod] )\n  \n      |  \n \n       sfîrşit \n \n2.3. Traversarea ite rativă în inordine  \nIdeea procedurii constă în a \"coborî\" către stînga cît se poate de mult, pînă ce se ajunge la \nun nod, pe care -l notă m cu x care nu mai are descendenţi; în acest timp se trec în stivă \ntoate nodurile parcurse la stînga sa. Se vizitează nod ul x, după care, dacă nodul x este \nfrunză, se revine la \"tatăl sau\" care este  preluat din stivă. Dacă nodul x nu este frunză se \nîncearcă parcurgerea subar borelui sau drept.",
    "ga sa. Se vizitează nod ul x, după care, dacă nodul x este \nfrunză, se revine la \"tatăl sau\" care este  preluat din stivă. Dacă nodul x nu este frunză se \nîncearcă parcurgerea subar borelui sau drept.  Acest lucru este corect deoarece nodul x \nneavînd niciun descendent la stînga sa, d ar avînd unul la dreapta se poate spune că nodul \nx constituie Rădăcina unui n ou subarbore avînd la rîndul sau un subarbore stîng vid şi \nunul drept nevid.  \n \n              ┌ procedura  SRD_iterrativ(a) este \n              | nod = *) Rădăcina arborelui  \n              | *)iniţializează stiva  \n              | ┌ repetă \n              | |   ┌ cît timp F_ST[nod]= \\ 0 execută \n              | |   |      push (nod)  \n              | |   |      nod = F_ST [nod]  \n              | |   └ \n  \n              | |   Vizitează(nod)  \n              | |   ┌ cît timp  F_DR[nod] = 0 execută \n              | |   |      dacă *)stiva vidă atunci  sfîrşit  \n              | |   |      nod = top_pop(stiva)  \n              | |",
    "tează(nod)  \n              | |   ┌ cît timp  F_DR[nod] = 0 execută \n              | |   |      dacă *)stiva vidă atunci  sfîrşit  \n              | |   |      nod = top_pop(stiva)  \n              | |   |     Vizitează(nod)  \n              | |   └ \n  \n              | |   nod = F_ DR [nod]  \n              | └ pînă_cînd  *)la infinit  \n              └ sfîrşit  \n \n     Se observă deci că primul ciclu cît timp  efectuează parcurgerea către stînga, după care \nurmează vizitarea nodului fără descendent stîng. Al doilea ciclu are ca efect vizitarea \nascendenăilor acestui nod, cît timp aceşti ascendenăi (iniţial chiar nodul vizitat î nainte de \nînceperea ciclului) nu au descendenţi la dreapta. De îndată ce este găsit un descendent la \ndreapta, acest ciclu se încheie şi se reia ciclul \"infinit\" repetă. Pro cedura se încheie atunci \ncînd stiva este găsită vidă în cadrul vizitării ascendenţil or. \n \n  Algoritmi de traverasare a arborilor binari  \nAlgoritm  RSD SRD SDR lăţime  \nrecursiv  da da da nu",
    ". Pro cedura se încheie atunci \ncînd stiva este găsită vidă în cadrul vizitării ascendenţil or. \n \n  Algoritmi de traverasare a arborilor binari  \nAlgoritm  RSD SRD SDR lăţime  \nrecursiv  da da da nu \ncu SD auxiliară  stivă stivă stivă coadă  \n \nTema acasa  \n \n1. Proiectaţi un al goritm iterativ de traversare în postordine a unui arbore binar care sa \nfunctioneze pe interfata grafica (veti introduce  o optiune noua in ListView) ( 5p)  \n2. Concepeţi o nouă metodă de evaluare a expresiilor reprezentate prin arbori binari \nutilizând o metodă  de traversare şi evaluarea expresiilor postfixate  (5 p) \n3. Realizaţi o clasă ArboreBin arComplet care să reprezinte arborele printr -un vector de \nnoduri. Programaţi cele 4 metode remarcabile de traversare (5p). \n4. Programaţi o metodă de derivare simbolică a expre siilor reprezentate prin arbori. \nCreaţi un program demonstrativ care să calculeze va loarea unei expresii funcţie de \nvaloarea unei variabile şi valoarea derivatei expresiei în funcţie",
    "olică a expre siilor reprezentate prin arbori. \nCreaţi un program demonstrativ care să calculeze va loarea unei expresii funcţie de \nvaloarea unei variabile şi valoarea derivatei expresiei în funcţie de aceeaşi variabilă \n(10p). \n \n \n \nANEXA  \nEvaluarea expresiilor reprezentate s ub forma de arbore (Python)  \n \n# infinit  \ninf = float('inf')  \n \ndef este_frunza(nod):  \n    return nod[1]==None and nod[2]==None  \n \ndef impartire(x,y):  \n    if y==0:  \n        return inf  \n    return x/y  \n \ndef calcul(x, op, y):  \n    operatii = {'+': lambda x,y:x+y,  \n             '-': lambda x,y:x -y, \n             '*': lambda x,y:x*y,  \n             '/': imp artire }  \n    return operatii[op](float(x),float(y))  \n \n \ndef evalArb(nod):  \n    if este_frunza(nod):  \n        return float(nod[0])  \n    return calcul(evalArb(nod[1]), nod[0], eva lArb(nod[2]))  \n \nif __name__ =='__main__':  \n    # expr. de test = (5+9)/2  \n    etest = [ '/', [ '+', ['5', None, None], ['9', None, None] ], ['2', None, None] ]",
    "calcul(evalArb(nod[1]), nod[0], eva lArb(nod[2]))  \n \nif __name__ =='__main__':  \n    # expr. de test = (5+9)/2  \n    etest = [ '/', [ '+', ['5', None, None], ['9', None, None] ], ['2', None, None] ]  \n    # expr. cu div. la zero = (10+20) / (30 - 30) \n    edivzero = ['/', [ '+', ['10', None, None], [' 20', None, None] ],  \n                    [ '-', ['30', None, None], ['30', None, None ] ] \n               ] \n    print (evalArb (etest) )  \n    print (evalArb (edivzero) )",
    "Laborator 12  \n \nSunteti rugat i sa scrieti o aplicatie Java care sa -l ajute pe Mosu’  in distribuirea cadourilor pentru \nstudenti.  Aplicatia va afisa un panou ca cel de mai jos.  \n \n(imagine brad preluata de la http://www.fanpop.com/clubs/christmas/images/12140793/title/christmas -photo ) \n \nMosu’ are lista  sa cu student i si, date fiind capacitatile sale supranaturale , pentru fiecare student a \npastrat doar numele, media si localitatea . Restul informatiilor le stie el foarte bine …  \nLista de student i a fost organizata pe aceste 3 informatii : numele, media si localitatea.  \nIn aplicatie daca utilizatorul selecteaza un nume, de exemplu Ionel , se vor afisa toti studentii pe care \nii cheama Ionel , indiferent de medie sau localitate. .  \nDaca se va selecta o localitate (in figura Suceava) se vor afisa toti stdentii din acea localitate , \nindiferent ce nume sau medie au . \nDaca utilizatorul  muta slider -ul din partea inferioara pe o noua valoare, de ex.",
    "o localitate (in figura Suceava) se vor afisa toti stdentii din acea localitate , \nindiferent ce nume sau medie au . \nDaca utilizatorul  muta slider -ul din partea inferioara pe o noua valoare, de ex. 9.50, in zona TextArea \nse vor af isa toti studentii care au media  cel putin egala cu 9.50, indiferent de numele, sau localitatea \nselectata.  \n\nAplicatia porneste cu o date  de test, insa daca se va  apasa pe butonul “Citeste fisier” se va citi un fisier \n.txt avand inregistrari cu formatul in care sunt afisate in figura de mai sus informatiile despre student  \n(informatiile despre un student pe o singura linie cu campurile separate prin virgula) .  \nCitirea fisierului presupune crearea obiectelor Student , cate unul pentru fiecare linie  din fisier , cat si \ninregistrarea lor in structurile de cautare care sa permita regasirea rapida a studentilor dupa nume, \nmedie ori  localitate.  \nAveti la dispozitie  \nPachetul se va numi, in mod mormal, obradfrumos .",
    "inregistrarea lor in structurile de cautare care sa permita regasirea rapida a studentilor dupa nume, \nmedie ori  localitate.  \nAveti la dispozitie  \nPachetul se va numi, in mod mormal, obradfrumos . \nClasa Student  \npackage obradfrumos;  \n \npublic class Student {  \n    private String nume;  \n    private double medie;  \n    private String localitate;  \n \n    public Student(String nume, double varsta, String localitate)  { \n        this.nume = nume;  \n        this.medie = varsta;  \n        this.localitate = localitate;  \n    } \n    public String getNume() {  \n        return nume;  \n    } \n    public double getMedie() {  \n        return medie;  \n    } \n    public String getLocalitate() {  \n        return localitate;  \n    } \n    @Override  \n    public String toString() {  \n        return nume + \", \" + medie + \", \" + localitate;  \n    } \n} \nClasa ListaMosului  \nAceasta clasa permite functionarea aplicatiei cu cele cateva date de test.",
    "e  \n    public String toString() {  \n        return nume + \", \" + medie + \", \" + localitate;  \n    } \n} \nClasa ListaMosului  \nAceasta clasa permite functionarea aplicatiei cu cele cateva date de test. P entru ca sa functioneze cu \ndatele Mosului va trebui completata cu un constructor ca cel indicat mai jos.  \npackage obradfrumos;  \nimport java.io.File;  \nimport java.util.ArrayList;  \nimport java.util.Arrays;  \nimport java.util.List;  \nimport java.util.Map;  \nimport java.util.TreeMap;  \n \npublic class ListaMosului {  \n \n    private Map<String, List<Student>> mapNume = new TreeMap<>();  \n    private Map<Double, List<Student>> mapMedie = new TreeMap<>();  \n    private Map<String, List<Student>> mapLocalitate = new TreeMap< >(); \n \n    public ListaMosului ( File f  ) { \n \n        // DE COMPLETAT  \n  \n   } \n    public ListaMosului() {  \n        for (Student s : exempluDeTest()) {  \n            inscrieInListaMosului(s);  \n        } \n    } \n    public void inscrieInListaMosului(Student s) {",
    "AT  \n  \n   } \n    public ListaMosului() {  \n        for (Student s : exempluDeTest()) {  \n            inscrieInListaMosului(s);  \n        } \n    } \n    public void inscrieInListaMosului(Student s) {  \n        adaugaInMap(mapNume, s.getNume(), s);  \n        adaugaInMap(mapMedie, s.getMedie(), s);  \n        adaugaInMap(mapLocalitate, s.getLocalitate(), s);  \n \n    } \n    private void adaugaInMap(Map<String, List<Student>> map, String k, Student s) {  \n        List<Student> lst = map.get(k);  \n        if (lst == null) {  \n            lst = new ArrayList<>();  \n            map.put(k, lst);  \n        } \n        lst.add(s);  \n    } \n \n    private void adaugaInMap(Map<Double, List<Student>> map, Double k, Student s) {  \n        List<Student> lst = map.get(k);  \n        if (lst == null) {  \n            lst = new ArrayList<>();  \n            map.put(k, lst);  \n        } \n        lst.add(s);  \n    } \n \n    private List<Student> exempluDeTest() {  \n        Student[] lstStud = new Student[]{ne w S",
    "lst = new ArrayList<>();  \n            map.put(k, lst);  \n        } \n        lst.add(s);  \n    } \n \n    private List<Student> exempluDeTest() {  \n        Student[] lstStud = new Student[]{ne w Student(\"Ionel\", 6.55, \"Suceava\"),  \n            new Student(\"Viorel\", 7.45, \"Suceava\"),  \n            new Student(\"Violeta\", 6.55, \"Radauti\"),  \n            new Student(\"Elena\", 8.25, \"Cajvana\"),  \n            new Student(\"Mariana\", 9.75, \"Suceava\"),  \n            new Student(\"Costel\", 6.55, \"Radauti\"),  \n            new Student(\"Ionel\", 8.25, \"Cajvana\"),  \n            new Student(\"Violeta\", 8.55, \"Campulung Moldovenesc\"),  \n            new Student(\"Ioana\", 8.35, \"Vatra -Dornei\")};  \n        return Arrays.asList(lstStud);  \n \n    } \n    public Map<String, List<Student>> getMapNume() {  \n        return mapNume;  \n    } \n    public Map<Double, List<Student>> getMapMedie() {  \n        return mapMedie;  \n    } \n    public Map<String, List<Student>> getMapLocalitate() { \n        return mapLocal",
    "return mapNume;  \n    } \n    public Map<Double, List<Student>> getMapMedie() {  \n        return mapMedie;  \n    } \n    public Map<String, List<Student>> getMapLocalitate() { \n        return mapLocalitate;  \n    } \n} \nClasa principala: OBradFrumos  \nRealizeaza aplicatia grafica si are cod pentru a reactiona la schimbarea item -ului selectat su la \nmodificari ale valorii Slider -ului.  \nIn aceasta clasa veti avea mai mult cod de completa t. \npackage obradfrumos;  \nimport java.io.FileNotFoundException;  \nimport java.util.List;  \nimport java.util.Map;  \nimport javafx.application.Application;  \nimport javafx.beans.value.ChangeListener;  \nimport javafx.beans.value.ObservableValue;  \nimport javafx.collections.ObservableList;  \nimport javafx.scene.Scene;  \nimport javafx.scene.control.ChoiceBox;  \nimport javafx.scene.control.Label;  \nimport javafx.scene.control.Slider;  \nimport javafx.scene.control.TextArea;  \nimport javafx.scene.image.ImageView;  \nimport javafx.scene.layout.BorderPane;  \nimp",
    "import javafx.scene.control.Label;  \nimport javafx.scene.control.Slider;  \nimport javafx.scene.control.TextArea;  \nimport javafx.scene.image.ImageView;  \nimport javafx.scene.layout.BorderPane;  \nimport javafx.scene.layout.HBox;  \nimport javafx.scene.text.Text;  \nimport javafx.stage.Stage;  \n \npublic class NewClass extends Application {  \n    private static TextArea rezultatCautare;  \n    private static Label nrInregistrari;  \n    private ImageView imageView = new ImageView();  \n    private Text topText;  \n    private Label eticValSelectata;  \n    private ListaMosului listaMosului;  \n// \n// puteti COMPLETA  cu campuri si metode  \n// \n \n    private static  TextArea getTextArea(String textInitial) {  \n        TextArea ta = new TextArea();  \n        ta.appendText(textInitial);  \n        ta.setPrefWidth(400);  \n        ta.setPrefHeight(370);  \n        ta.setWrapText(true);  \n        return ta;  \n    } \n    private ChoiceBox getChoiceBox(Map<String, List<Student>> map ) { \n        Observab",
    "etPrefWidth(400);  \n        ta.setPrefHeight(370);  \n        ta.setWrapText(true);  \n        return ta;  \n    } \n    private ChoiceBox getChoiceBox(Map<String, List<Student>> map ) { \n        ObservableList<String> listaItemi;  \n       // \n       //   DE COMPLETAT  listaItemi  cu valorile cheilor din map  \n       //   \n       // sugestie clasa ConsultareDictionar din aplicatia Dictionar ilustrat  prezentata  \n       // la cursul  Controale grafice  \n       // \n        ChoiceBox<String> list = new ChoiceBox<>(listaItemi);  \n \n        list.getSelectionModel().selectedItemProperty()  \n                .addListener(new SelectareItem(map));  \n       // este necesar sa scrieti clasa SelectareItem care sa implementeze ChangeListener  \n      //  scheletul clasei  SelectareItem  este prezentat in con tinuare  \n        return list;  \n    } \n \n    Slider getSlider() {  \n        Slider valMedie;  \n       // \n       //    DE COMPLETAT  \n       //  sugestie pentru Slider: cursul Scurt tutorial JavaFX",
    "n tinuare  \n        return list;  \n    } \n \n    Slider getSlider() {  \n        Slider valMedie;  \n       // \n       //    DE COMPLETAT  \n       //  sugestie pentru Slider: cursul Scurt tutorial JavaFX ,  \n       // aplicatia FORMULARE CU CONTROALE GRAFICE DIVERSE  \n       //        \n \n      valMedie.valueProperty().addListener ( new ChangeListener<Number >()  {  \n            @Override  \n            public void changed(ObservableValue<? extends Number> ov,  \n                                                                                                    Number old_val, Number new_val) {  \n                double valSelectata = new_val.doubleValue();  \n                eticValSelectata.setText(String.format(\"Stud. cu media >= %.2f\", new_val));  \n                List <Student> lstDupaMedie;  \n                // \n               //  DE COMPLETAT cu instructiunile pentru obtin erea listei studentilor   \n               //  lstDupaMedie  care au media cel putin egala cu new_val",
    "// \n               //  DE COMPLETAT cu instructiunile pentru obtin erea listei studentilor   \n               //  lstDupaMedie  care au media cel putin egala cu new_val  \n               // \n                afisareRezultat(lstDupaMedie);  \n            } \n        }); \n        return valMedie;  \n    } \n \n    // package protected  \n    static void afisareRezultat(List<Student> lstud) {  \n       // \n       // DE COMPLETAT  \n       //  \n    } \n \n    private BorderPane getPanou() {  \n        BorderPane panou = new BorderPane();   \n       // \n       //    DE COMPLETAT      \n       // \n       // sugestie : aplicatia Dictionar ilustrat  prezentata  \n       // la cursul  Controale grafice  \n       // \n        Slider valMedie = getSli der();  \n       // sugestie pentru Slider: cursul Scurt tutorial  JavaFX,  \n       // aplicatia FORMULARE CU CONTROALE GRAFICE DIVERSE  \n        eticValSelectata = new Label(\"  .",
    "der valMedie = getSli der();  \n       // sugestie pentru Slider: cursul Scurt tutorial  JavaFX,  \n       // aplicatia FORMULARE CU CONTROALE GRAFICE DIVERSE  \n        eticValSelectata = new Label(\"  . . .  DE COMPLETAT . . . \" ); \n \n        panou.setBottom(new HBox(10, valMedie, eticValSelectata));  \n        return panou;  \n    } \n \n    @Override  \n    public void start(Stage primaryStage) throws FileNotFoundException {  \n        listaMosului = new ListaMosului();  \n        Scene scena = new Scene(getPanou(), 700, 500);  \n        primaryStage.setScene(scena);  \n        primaryStage.setTitle(\"O, brad frumos!\");  \n        primaryStage.show();  \n    } \n \n    public static void main(String[] args) {  \n        launch(args);  \n    } \n \n} \nClasa  SelectareItem  \npackage obradfrumos;  \nimport java.util.List;  \nimport java.util.Map;  \nimport javafx.beans.value.ChangeListener;  \nimport javafx.beans.value.ObservableValue;  \npublic class SelectareItem implements ChangeListener<String>{  \n    Map<?",
    ".util.List;  \nimport java.util.Map;  \nimport javafx.beans.value.ChangeListener;  \nimport javafx.beans.value.ObservableValue;  \npublic class SelectareItem implements ChangeListener<String>{  \n    Map<?, List<Student>> map;  \n  // \n  // DE COMPLETAT  \n  // \n  } \n \nTEMA DE EFECTUAT  \n1. (4p ) Scrieti codul necesar pentru a afisa panoul cu toate controalele grafice  \n \nPunctaj: 1p pentru cele 2 ChoiceBox + buton,  1p slider, 1p TextArea si imaginea, 1p \ndispunerea se mentine si la maximizarea ferestrei).  \n2. (3p)  Controalele grafice reactioneaza si afiseaza datele de test (1p – nume, 1p – localitate, \n1p slider medie).  \n3. (3p)  Controalele grafice reactioneaza si afiseaza datele din Fisier  – campurile fiind  separate \nprin virgula). Atentie. Fereastra pentru citirea fisierului va apare inainte de afisarea \npanoului grafic. Daca utilizatorul actioneaza butonul Anulare (Can cel) se vor incarca datele \nde test.",
    "arate \nprin virgula). Atentie. Fereastra pentru citirea fisierului va apare inainte de afisarea \npanoului grafic. Daca utilizatorul actioneaza butonul Anulare (Can cel) se vor incarca datele \nde test.  Dupa  ce s-a stabilit setul de date  urmeaza afisa rea panoul ui graphic.   Procesarea \nactionarii butonului “Citeste fisier”  este ultimul punct al Temei pentru acasa.  \n IMPORTANT  \nDupa cum banuiti , nimeni nu cunoaste lista  cu care lucreaza  Mosul.  \nFisierul pus la dispozitie contine 1001  de inregistrari fictive, fara nici o legatura \ncu realitatea si are doar scopul de a va putea testa aplicatia cu un  astfel de  \nvolum de date .  \nCoincidenta dintre unele informatii din fisi er si perso ane reale este cu totul \nsi cu totul intamplatoare!  \n \nPunctaj: 1p citire fisier si afisare in TextArea, 0.5p – nume, 0.5p – localitate, 1p slider medie).  \n \nTEMA ACASA  \n1. (3p) Adaugati un camp text inainte de ChoiceBox -ul cu nume, in care sa puteti introduce un \nsir.",
    "e fisier si afisare in TextArea, 0.5p – nume, 0.5p – localitate, 1p slider medie).  \n \nTEMA ACASA  \n1. (3p) Adaugati un camp text inainte de ChoiceBox -ul cu nume, in care sa puteti introduce un \nsir. Acest camp va fi sensibil la modificarile de continut si va popula ChoiceBox -ul doar cu \nacele nume din lista care contin subsirul din TextField.  \n2.  (3p) Introduceti pe aceeasi linie cu eticheta cu nr. de inegistrari un control CheckB ox cu \ntextul “ Se ia in considerare SI media ” Daca este selectat acest CheckBox in zona TextArea vor \nfi afisati studentii  \n• care au un anumit nume si au media>= valoarea selectata cu slider, sau  \n\n• cei care sunt dintr -o anumita localitate si au media>= valoare a selectata cu slider  \nfunctie de care ChoiceBox (Nume sau Localitate) a fost utilizat. Afisarea in TextArea se \nmodifica ori de cate ori se modifica una din cele 3 selectii.  \n3. (3p) Introduceti pe aceeasi linie un nou control CheckBox cu textul “ Toate”.",
    "u Localitate) a fost utilizat. Afisarea in TextArea se \nmodifica ori de cate ori se modifica una din cele 3 selectii.  \n3. (3p) Introduceti pe aceeasi linie un nou control CheckBox cu textul “ Toate”. In ace st caz vor \nfi afisati studentii care indeplinesc simultan  toate cel 3 conditii : sa aiba numele identic cu cel \nselectat, localitatea identica cu cea selectata si media>= valoarea selectata cu slider.  \nAfisarea in TextArea se modifica ori de cate ori se modif ica una din cele 3 selectii.  \n4. (3p) Modificarea datelor cu care lucreaza aplicatia prin citirea unui nou fisier in timpul \nexecutiei la  actionarea butonului “Citeste fisier” . \nIndicatie . Pentru a schimba dinamic  item -ii dintr -o lista de selecti e (Choice Box) puteti  utiliza  \nlistaSelectie .getItems(). setAll( colectie ) care va face reinitializa rea listei (clear() ) si va a dauga \nelementele din colectie.  \nProbabil veti  lucra  cu aceleasi 3 Map -uri (nume, localitate, med ie) pe tot timpul executiei \nprogramul",
    "e ) care va face reinitializa rea listei (clear() ) si va a dauga \nelementele din colectie.  \nProbabil veti  lucra  cu aceleasi 3 Map -uri (nume, localitate, med ie) pe tot timpul executiei \nprogramului. Atunci reincarcarea lor cu datele din fisier  trebuie sa fie precedata de \nreinitializarea lor cu map .clear()  pentru  a le goli de vechiul continut .",
    "Laborator 1  \n \nFie prezentarea prez_1  de la Limbajul Java  aflata adresa http://apollo.eed.usv.ro/~pentiuc/sd/  \n1. Parcurge ti slide -urile 32 -36 \n2. Modificati codul din slide -ul 32 (class Factorial ) astfel incat sa verificati daca ce s -a introdus \neste un intreg (fara try; revedeti primele slide -uri). \n3. Scrieti o clasa EcuatieGrad1  care sa aiba un constructor cu 2 parametri, coeficientii a si b, si \ncare sa resolve ecuatia ax+b=0. Clasa va avea metodele  \n• getteri si setteri  \n• toString() – va returna  “ax+b=0 ” unde in loc de a si b vor fi  valorile coeficientilor  \n• rezolva() care va returna valoarea lui x;  \n            Ce solutie folositi pentru cazul in care ecuatia nu are solutii sau are o infinitate de solutii ?  \n4. Scrieti o clasa Punct  cu un constructor Punct() – creeaza x=y=0 si Punct(x,y).  \nClasa va avea metodele  \n• getteri si setteri  \n• toString() – va returna  “(x,y) ” unde in loc de x si y vor fi  valori numerice  \n• distanta(Punct p) – returneaza dis",
    "creeaza x=y=0 si Punct(x,y).  \nClasa va avea metodele  \n• getteri si setteri  \n• toString() – va returna  “(x,y) ” unde in loc de x si y vor fi  valori numerice  \n• distanta(Punct p) – returneaza distanta dintre punctul  current si punctul p. Se va \ncalcula D istant a Euclidiana. Fie p(xp,yp) si q(xq,yq), distanta dintre p si q se va calcula \nastfel:      d(p,q) = sqrt( (xp-xq)^2 + (yp-yq)^2)  \nTestati clasa citind coordonatele a 2 puncte si afisand cele 2 puncte si distanta di ntre ele.  \n5. Creati o clasa Poligon  care va avea si o metoda care calculeaza perimetrul poligonului \nreprezentat prin punctele corespunzatoare varfurilor sale.  \n• Se va citi dintr -un fisier coordonatele mai multor puncte care reprezinta varfurile \nunui poligon si se vor afisa  \ni. Varfurile poligonului  \nii. Perimetrul poligonului.  \nExemplu de fisier  \n3 \n4 5 \n10 7  \n6 3 \n \nObligatoriu veti folosi clasa Punct  creata anterior .",
    "inta varfurile \nunui poligon si se vor afisa  \ni. Varfurile poligonului  \nii. Perimetrul poligonului.  \nExemplu de fisier  \n3 \n4 5 \n10 7  \n6 3 \n \nObligatoriu veti folosi clasa Punct  creata anterior . \n \nPentru documentatia claselor  Java consultati  \nhttps://docs.oracle.com/javase/8/docs/api/  \nPentru clasa String link -ul direct este \nhttps://docs.oracle.com/javase/8/docs/api/java/lang/String.html  \nTutoriale  \nhttps://docs.oracle.com/javase/tutorial/  \nhttps://www.w3schools.com/java/default.asp",
    "Laborator 2 \n \nCalculul Salariilor  \n \nFie o firm ă care are mai multe categorii de angajați .  \nPentru aplicația  pe care o veți realiza va lua în considerare doar dou ă categorii : ingineri  și  șoferi .  \nIn firmă  este fixat un salariu orar minim de 15 lei/or ă, iar fiecare categorie are un coeficientSlarial  \npropriu. Salariul orar al unei categorii de angajati este egal cu  \nsalariul OrarCategorie   = salariuOrarMinim  x coeficientSlarial _categorie  \nInginerii  sunt plătiț i proporțional  cu nr de ore lucrate  \nsalariu Inginer = salariul OrarInginer  x nrOreLucrate  \nPentru un inginer coeficientSlarial  = 1.5 , iar numărul  de ore lucrate pe luna nu poate fi mai mare \nde 250.  \nȘofer ii sunt plătiți  proporțional  cu nr de ore lucrate la care se adaugă  un bonus care depinde de \nkilometrii parcurși  \nsalariu Sofer = salariul OrarSofer x nrOreLucrate  + kmParcursi  x 0.1 \nPentru toți  șoferii  avem  coeficientSlarial  = 1.00 , iar numărul  de ore lucrate pe lun ă nu poate fi ma",
    "ilometrii parcurși  \nsalariu Sofer = salariul OrarSofer x nrOreLucrate  + kmParcursi  x 0.1 \nPentru toți  șoferii  avem  coeficientSlarial  = 1.00 , iar numărul  de ore lucrate pe lun ă nu poate fi mai \nmare de 300 și  km parcurși  nu pot fi mai mulți  de 5000.  \nInterfata  IAngajat  \nAceast ă interfaț ă va fi implementat ă în mod obligatoriu de clasele Inginer  și  Șofer . \npublic interface IAngajat {  \n    public static final double salariuOrarMinim=15;  \n    public void setNrOreLucrate(int nrOreLucrate);  \n    public double salariu();  \n} \n \nNota . In interfete le Java  variabilele sunt implicit  public static final  deoarece  \n- public – trebuie s a fie vizibile in toate clasele care implementeaza interfata  \n- static - trebuie sa  existe inainte de orice instanta a unei clase care o implementeaza  \n- final  - fiind comune tuturor claselor care implementeaza interfata ele nu trebuie sa poata \nfi modificate  \nDe aceea  prezenta in declaratie a public static final este e ste redundan",
    "mplementeaza  \n- final  - fiind comune tuturor claselor care implementeaza interfata ele nu trebuie sa poata \nfi modificate  \nDe aceea  prezenta in declaratie a public static final este e ste redundanta (declaratia \nputea fi doar double salariuOrarMinim=15;  )  \n1. Creati clasele  Persoana, Inginer, Sofer, \nCalculSalarii   (5p) \n- Persoana   (nume, prenume ) \n \nAceasta clasa va avea doar câmpurile  și  metodele din figura următoare : \n \n \n- Inginer  – extinde Persoana   și  implementeaza IAngajat  \n \n- Sofer  – extinde Persoana   și  implementeaza IAngajat  \nClasele Inginer  și  Sofer  : \n- vor avea toate campurile necesare pentru a produce afisarea ceruta de aplicatie  \n- IMPORTANT:  metodele toString()  din Inginer  și  Sofer  vor folosi metoda toString() din clasa \nPersoana . \n \n- CalculSalarii  – va fi o clasa care contine doar metoda main()  în care  \no se instantiaza  3 obiecte:  2 ingineri  și  un șofer (folositi datele din exemplul de iesire \nde mai jos)  \no se actualizeaza num",
    "lSalarii  – va fi o clasa care contine doar metoda main()  în care  \no se instantiaza  3 obiecte:  2 ingineri  și  un șofer (folositi datele din exemplul de iesire \nde mai jos)  \no se actualizeaza numarul de ore lucrat e la  100, 200  și  respectiv 250  de ore,  \no se actualizeaza  și  faptul ca  șoferul a parcurs 1000 km  \no se afiseaza salariul fiecaruia  \no se afiseaza Total salari i calculat ca suma salariilor angajatilor  \n \nIesirea produsa de program trebui e sa fie ca cea de mai jos  \nInginer Barbulescu Barbu  a lucrat 100 ore - slariu=2250.0  \nInginer Trestie Tudor  a lucrat 200 ore - slariu=4500.0  \nSofer Repede Raul  a lucrat 250 ore, a parcurs 1000 km - slariu=3850.0  \nTotal salarii=10600.0  \n \n\n Referitor la punctajul acordat:  \n- daca metodele toString() din Inginer  și  Sofer  NU vor folosi metoda \ntoString() din clasa Persoana  atunci punctajul se va diminua cu 2x \n0.5p = 1p  \n- daca – clasele Inginer  și  Sofer NU vor extinde Persoana   și  NU \nimplementeaza IAngajat at",
    "NU vor folosi metoda \ntoString() din clasa Persoana  atunci punctajul se va diminua cu 2x \n0.5p = 1p  \n- daca – clasele Inginer  și  Sofer NU vor extinde Persoana   și  NU \nimplementeaza IAngajat atunci punctajul se va diminua cu 2 x (2x \n0.5p) = 2p  \n \n \n \n2. Rescrieti aplicatia renuntand la interfata IAngajat \n(3p) \nFaceti o copie a proiectului precedent, redenumiti copia salariiAngajati  și  faceti modificarie  în \naceasta copie astfel incat la sfarsitul laboratorului sa puteti prezenta ambele proiecte pentru \nacordarea de puncte.  \nIndicatie : Veti scrie o clasa Angajat  care sa extinda clasa Persoana . Clasele Inginer  și  Sofer  vor \nextinde Angajat . \n Se acorda 1 p  dacă se produce aceeași  ieșire  cu aceleași date de intrare . \n \nCelelalte 2p se acord ă dacă clasele Inginer  și  Sofer  au cel mult aceeași  \nmembri  – metode  și  campuri - ca în figura de mai jos.  \n \n \n \n \nVariabila mrMaxOreLucrate are valoarea 250 pentru orice inginer  și  300 pentru orice Șofer, iar \nvaria",
    "Sofer  au cel mult aceeași  \nmembri  – metode  și  campuri - ca în figura de mai jos.  \n \n \n \n \nVariabila mrMaxOreLucrate are valoarea 250 pentru orice inginer  și  300 pentru orice Șofer, iar \nvariabila kmParcursiMax are valoarea 5000 pentru orice șofer. \n3. Scrieți  clasa Firma    (2p) \nClasa Firma  va memora toți angajații  și  va permite preluarea orelor lucrate de toti angajatii \ndintr -un fișier  pontaj.txt  care va avea formatul ca  în exemplul urmator  \n \n101 100 \n23 200 \n302 250 1000  \n  \n\nPrimul numar este ID -ul propriu fiecarui angajat . Un intreg. Nu exista 2 angajati  diferi ti cu \nacelasi ID.  Veti complet a în mod corespunzator  aplicatia din ultimul proiect .  \nDupa ID, celalalt numar/c elelalte numere de pe o linie din fisier  reprezinta numarul de ore \nlucrate, eventual numarul de km parcursi.  \n \nClasa Firma  va avea  și  metode care:  \no Afiseaza salariile tuturor angajatilor  \no Calculeaza Total salarii  \nVeti scrie si o metoda  \nAngajat getAngajatDupaID  (int ID",
    "numarul de km parcursi.  \n \nClasa Firma  va avea  și  metode care:  \no Afiseaza salariile tuturor angajatilor  \no Calculeaza Total salarii  \nVeti scrie si o metoda  \nAngajat getAngajatDupaID  (int ID) ; \ncare va returna an gajatul cu ID -ul primit ca argument.  \n \nLink-uri utile  \n1. Pentru documentatia claselor  Java consultati  \nhttps://docs.oracle.com/javase/8/docs/api/  \n2. O aplicatie asemanatoare este prezentata  în cartea recomandata : Building Java \nPrograms: A Back to Basics Approach, 5th edition, by Stuart Reges and Marty  \nStepp, Consultati prezentarea pt. cap. 9 de la adresa \nhttp://www.buildingjavaprograms.com/supplements5.shtml  \n3. Daca utilizati clasa Scanner  atentie  dacă alternati nextInt() cu nextLine(). A  se \nvedea prezentarea din cap.6 din aceeasi pagina  web  \nhttp://www.buildingjavaprograms.com/supplements5.shtml",
    "://www.buildingjavaprograms.com/supplements5.shtml",
    "Laborator 3. Polimorfism  \n \nNave maritime civile  \n \nConstruiti o structura de clase corespunzatoare figurii urmatoare:  \n  \nNava  NavaCroaziera  \nnume , pavilion  nume, pavilion  \n nrPasageri  \n \n \n \nCargou  Feribot  \nnume, pavilion  nume, pavilion , nrPasageri  \ncapacitateIncarcare  nrAuto  \n \nFiecare nava specializata va fi reprezentata prin metodele  \n- utilizar e() – se va afisa la ce serveste nava (‘Croaziere de lux’,  ‘Transport marfuri’, ‘Transport \nvehicule si pasageri’,  \n- toString() – afiseaza toate informatiile depsre nava respectiv a \n \n1. Scrieti clasa Nava , subclasa ei NavaCroaziera  si o clasa Flota   (4p) \nClasa Nava  \nPoate fi o clasa abstracta, care sa contina campurile nume, pavilion.  \n- Constructor: Nava(nume, pavilion)  \n\n- toString () – gasiti o solutie astfel incat sa poata fi apelata unitar din subclase  \n- utilizare() – metoda abstracta  \n \nClasa NavaCroaziera  \nExtinde clasa Nava .",
    "tructor: Nava(nume, pavilion)  \n\n- toString () – gasiti o solutie astfel incat sa poata fi apelata unitar din subclase  \n- utilizare() – metoda abstracta  \n \nClasa NavaCroaziera  \nExtinde clasa Nava . \no Constructor cu parametrii : nume, pavilion, nrPasageri  \no utilizare() – afiseaza ‘Croaziere de lux’  \no toString() – returneaza un sir ca cel de mai jos:  \n“NavaCroaziera - nume=Suceava, pavilion=RO, nrPasageri=1000”  \n \nSe vor crea 2 nave de croaziera:  \n- Suceava, pavilion RO, maxim 1000 de pasageri  \n- Victoria, pavilion RO, 5000 de pasageri  \n \nClasa Flota  \nClasa Flota va contine un  tablou de tip Nava cuprinzand toate navele din flota.  \no Constructor: Flota() – aloca un tablou  Nava nave[10]  (obligatoriu in aceasta \nlucrare de laborator ) si nr. de nave egal cu 0  \no toString() – returneaza un sir cu componenta flotei  \no utilizare() – afiseaza u tilizarea navelor din flota  \no adaugaNava(Nava x) – introduce nava x in flota (in tabelul nave[])  \nObservatie .",
    "0  \no toString() – returneaza un sir cu componenta flotei  \no utilizare() – afiseaza u tilizarea navelor din flota  \no adaugaNava(Nava x) – introduce nava x in flota (in tabelul nave[])  \nObservatie . Daca la apelul metodei adaugaNava() se va constata ca nu mai este loc in tabelul nave[] \natunci se va realoca acest tabel utilizand urmatoarea functie statica din clasa Arrays  \npublic static <T> T[] copyOf(T[] original, int newLength)  \ncare realizeaza o copie a vechiului tabel completandu -l cu null daca noua lungime este mai mare.  \nGenericitate <T> este cunoscuta de la C++.  \nMetoda  main() a clasei Flota  poate fi urmatoarea:  \npublic static void main(String[] args) {  \n  Flota flota1= new Flota();  \n  NavaCroaziera sv = new NavaCroaziera(1000, \"Suceava\", \"RO\");  \n  System.out.print(sv + \" \\nUtilizare:\");  \n  sv.utilizare();  \n  System.out.println (); \n   \n  flota1.adaugaNava( sv);  \n  flota1.adaugaNava(new NavaCroaziera(5000, \"Victoria\", \"RO\"));  \n  System.out.println(flota1);  \n  f",
    "\" \\nUtilizare:\");  \n  sv.utilizare();  \n  System.out.println (); \n   \n  flota1.adaugaNava( sv);  \n  flota1.adaugaNava(new NavaCroaziera(5000, \"Victoria\", \"RO\"));  \n  System.out.println(flota1);  \n  flota1.utilizare();  \n}       \n \nIesirea produsa in acest caz va trebui sa fie astfel:  \nNavaCroaziera - nume=Suceava, pavilion=RO, nrPasageri=1000  \nUtilizare:Croaziere de lux  \n \nFlota: \n1. NavaCroaziera - nume=Suceava, pavilion=RO, nrPasageri=1000  \n2. NavaCroaziera - nume=Victoria, pavilion=RO, nrPasageri=5000  \n \nUtilizare flota:  \nSuceava - Croaziere de lux  \nVictoria - Croaziere de lux  \n \n2. Scrieti clasele Cargou (extinde clasa Nava) si Feribot  (extinde \nclasa NavaCroaziera)      (3p pentru solutia optima)  \nVeti completa metoda main()  din clasa Flota astfel incat sa se adauge in flota si o nava Cargou si una \nFeribot.  \nFlota: \n1. NavaCroaziera - nume=Suceava, pavilion=RO, nrPasageri=1000  \n2.",
    "optima)  \nVeti completa metoda main()  din clasa Flota astfel incat sa se adauge in flota si o nava Cargou si una \nFeribot.  \nFlota: \n1. NavaCroaziera - nume=Suceava, pavilion=RO, nrPasageri=1000  \n2. NavaCroaziera - nume=Victoria, pavilion=RO, nrPasageri=5000  \n3. Cargou - nume=Carpati, pavilion=RO, capacitateIncarcare=10000  \n4. Feribot - nume=Dunarea, pavilion=BG, nrPasageri=100, nrAuto=20  \n \nUtilizare flota:  \nSuceava - Croaziere de lux  \nVictoria - Croaziere de lux   \nCarpati - Transport marfuri  \nDunarea - Transport vehicule si pasageri  \n \n3. Adaugati clasei Flota  un nou constructor  (2p) \nAcesta va avea ca argument numele unui fisier  din care se va prelua descrierea flotei. Pe prima linie \nva fi dat numarul de nave din fisier, iar pe celelalte linii descrierea navelor, cate una pe linie,  \n<nume_nava>, <pavilion>, <tip_nava>,  … numere intregi care caracterizeaza nava ( tonaj, \nnr.pasageri , nrAuto, dupa tipul navei)  \nVeti folosi fisierul flota.txt  care contine  \n11 \nRegin",
    "pe linie,  \n<nume_nava>, <pavilion>, <tip_nava>,  … numere intregi care caracterizeaza nava ( tonaj, \nnr.pasageri , nrAuto, dupa tipul navei)  \nVeti folosi fisierul flota.txt  care contine  \n11 \nRegina Maria, RO, NavaCroaziera, 1500  \nCarpati, RO, Cargo, 10000  \nDunarea, BG, Feribot, 100, 20  \nInsula Misterioasa, RO, Feribot, 300, 75  \nIasi, RO, NavaCroaziera, 2500  \nApuseni, RO, Cargo, 20000  \nPlevna, BG, Cargo, 10020  \nBotosani, RO, NavaCroaziera, 500  \nNavodari, RO, Feribot, 300, 75  \nConstanta, RO, NavaCroaziera, 2500  \nUltima limita, RO, Cargo, 50000  \n \nVeti presupune ca fisierul contine numai i nformatii corecte. Nu e nevoie sa le validati, ci doar sa \nverificati capacitatea tabloului nave[].  \nIntrodceti in main() instructiunile:  \nFlota flota2 = new Flota(\"flota.txt\");  \nSystem.out.println(flota2);  \nflota2.utilizare();        \n \nIesirea produsa pentru acest fisier trebuie sa fie urmatoarea:  \nFlota: \n1.",
    "ain() instructiunile:  \nFlota flota2 = new Flota(\"flota.txt\");  \nSystem.out.println(flota2);  \nflota2.utilizare();        \n \nIesirea produsa pentru acest fisier trebuie sa fie urmatoarea:  \nFlota: \n1. NavaCroaziera - nume=Regina Maria, pavilion=RO, nrPasageri=1500  \n2. Cargou - nume=Carpati, pavilion=RO, capacitateIncarcare=10000  \n3. Feribot - nume=Dunarea, pavilion=BG, nrPasageri=100, nrAuto=20  \n4. Feribot - nume=Insula Misterioasa, pavilion=RO, nrPasageri=300, nrAuto=75  \n5. NavaCroaziera - nume=Iasi, pavilion=RO, nrPasageri=2500  \n6. Cargou - nume=Apuseni, pavilion=RO, capacitateIncarcare=20000  \n7. Cargou - nume=Plevna, pavilion=BG, capacitateIncarcare=1 0020 \n8. NavaCroaziera - nume=Botosani, pavilion=RO, nrPasageri=500  \n9. Feribot - nume=Navodari, pavilion=RO, nrPasageri=300, nrAuto=75  \n10. NavaCroaziera - nume=Constanta, pavilion=RO, nrPasageri=2500  \n11. Cargou - nume=Ultima limita, pavilion=RO, capacitateI ncarcare=50000  \n \nUtilizare flota:  \nRegina Maria - Croaziere de l",
    "to=75  \n10. NavaCroaziera - nume=Constanta, pavilion=RO, nrPasageri=2500  \n11. Cargou - nume=Ultima limita, pavilion=RO, capacitateI ncarcare=50000  \n \nUtilizare flota:  \nRegina Maria - Croaziere de lux  \nCarpati - Transport marfuri  \nDunarea - Transport vehicule si pasageri  \nInsula Misterioasa - Transport vehicule si pasageri  \nIasi - Croaziere de lux  \nApuseni - Transport marfuri  \nPlevna - Transport  marfuri \nBotosani - Croaziere de lux  \nNavodari - Transport vehicule si pasageri  \nConstanta - Croaziere de lux  \nUltima limita - Transport marfuri  \n \n4. Adaugati clasei Flota  o noua metoda de conversie la sir  (1p) \nAceasta metoda va avea proto tipul  \npublic String toStringFlota(boolean dupaNume);  \nDaca dupaNume=true  atunci va rezulta un sir ca cel de mai jos (navele apar in ordinea lexicografica a \nnumelui  \n“Flota: \n1. Cargou - nume=Apuseni, pavilion=RO, capacitateIncarcare=20000  \n2.",
    "ume);  \nDaca dupaNume=true  atunci va rezulta un sir ca cel de mai jos (navele apar in ordinea lexicografica a \nnumelui  \n“Flota: \n1. Cargou - nume=Apuseni, pavilion=RO, capacitateIncarcare=20000  \n2. NavaCroaziera - nume=Botosani, pavilion=RO, nrPasageri=500  \n3. Cargou - nume=Carpati, pavilion=RO, capacitateIncarcare=10000  \n4. NavaCroaziera - nume=Constanta, pavilion=RO, nrPasageri=2500  \n5. Feribot - nume=Dunarea, pavilion=BG, nrPasageri=100, nrAuto=20  \n6. NavaCroaziera - nume=Iasi, pavilion=RO, nrPasageri=2500  \n7. Feribot - nume=Insula Misterioasa, pavilion=RO, nrPasageri=300, \nnrAuto=75  \n8. Feribot - nume=Navodari, pavilion=RO, nrPasageri=300, nrAuto=75  \n9. Cargou - nume=Plevna, pavilion=BG, capacitateIncarcare=10020  \n10. NavaCroaziera - nume=Regina Maria, pavilion=RO, nrPasageri=1500  \n11. Cargou - nume=Ultima limita, pavilion=RO, capacitateIncarcare=50000  \n“ \n \nDaca dupaNume=false  atunci va rezulta un sir in care navele apar in ordinea lexicografica a \npavilionului (inta",
    "i=1500  \n11. Cargou - nume=Ultima limita, pavilion=RO, capacitateIncarcare=50000  \n“ \n \nDaca dupaNume=false  atunci va rezulta un sir in care navele apar in ordinea lexicografica a \npavilionului (intai cele cu BG si apoi cele cu RO).  \n \nSugestii  \n1. Daca intampinati probleme la citirea fisierului va poate fi de folos  Chapter 6: File \nProcessing  din cartea recomandata (se ga seste in sectiunea Suplements ) \n2. In clasa String  exista metod ele trim(),  split()  \nhttps://docs.oracle.com/ja vase/9/docs/api/java/lang/String.html  \n3. Utilizati clas ele StringBuilder , Arrays  si compararea obiectelor  \nhttp://apollo.eed.usv.ro/~pentiuc/sd/comparareObiecte.pdf  \n4. Privitor la sortarea/compararea obiectelor sugestii gasiti si in curs \nhttp://apollo.eed.usv.ro/~pentiuc/sd/comparareObiecte. pdf (pag 7 -15)",
    "df (pag 7 -15)",
    "Laborator 4 . Design Patterns  \n \nMagazin de cadouri - Jucări i \n \nAplicați a pe care o veți realiza ar putea deservi un \nmagazin de cadouri jucări i. \nFiecare jucări e are un preț  și se recomandă  să fie \nîmpachetată  într-un anumit tip de cutie  cadou cu \ndimensiuni  potrivite cu mărime a jucări ei. Desigur, \nse consider ă că toate jucări ile din magazin nu sunt \namb alate în cutii de produc ător.  \n \nClient ul poate cere ca jucări a pe care o cumpăr ă să fie sau nu  împachetată  într-o cutie  cadou . De \nasemenea mai poate solicita ca respectiv a cutie  să fie înfășurată  într-o panglica sau nu.  Cutia  și \npanglica au costuri funcți e de dimensiuni.  \nJucări ile \nAșa cum s -a amintit o rice jucări e este descris ă prin atributele : preț , tip cutie  în care se poate \nîmpacheta , dimensiunile cutiei. Nu se pot instanția  jucări i în general, ci jucări i specific e. Veți \nimplementa doar următoa rele trei tipuri de jucări i: \n• Minge ( preț  = 50, cutia recomandată  cubic ă, de dime",
    "siunile cutiei. Nu se pot instanția  jucări i în general, ci jucări i specific e. Veți \nimplementa doar următoa rele trei tipuri de jucări i: \n• Minge ( preț  = 50, cutia recomandată  cubic ă, de dimensiuni funcți e de mărime a mingii ) \n• Racheta ( preț  = 120 , cutia recomandată  cilindric ă, de dimensiuni funcți e de  jucări e) \n• Avion ( preț  = 100 , cutia recomandată  paralelipipedic ă, de dimensiuni funcți e de jucări e) \nÎn pachetul jucarii, pentru a asigura polimorfismul , puteți utiliza următoarea clasă abstractă \nca supertip  al tuturor claselor care vor reprezenta jucăriile Minge, Avion, Racheta  (pachetul cutii  \npackage jucarii; \n \nimport cutii.TipCutie ; \n \npublic abstract class Jucarie { \n        private double dimensiuni [] = new double [3]; \n \n        public abstract TipCutie getTipCutie (); \n        public abstract double getPret(); \n \n        public Jucarie(double l1, double l2, double l3) { \n            this.dimensiuni [0] = l1; \n            this.dimensiuni [1] = l",
    "utie getTipCutie (); \n        public abstract double getPret(); \n \n        public Jucarie(double l1, double l2, double l3) { \n            this.dimensiuni [0] = l1; \n            this.dimensiuni [1] = l2; \n            this.dimensiuni [2] = l3; \n        } \n        public double [] getDimensiuni () { \n            return dimensiuni ; \n        } \n} \nTipCutie  este prezentată în continuare. Pentru toString()  veți decide dacă implementați o \nmetod ă generală în clasa abstarctă sau met ode specifice în clasele concrete.  \n\nCutiile  \nCutiile  în care se pot împacheta  jucări ile sunt de trei tipuri specificate de următor ul enum  \npackage cutii; \npublic enum TipCutie { \n    PARALELIPIPED , CUB, CILINDRU ;    \n} \nUn exemplu de referire la aceste valori TipCutie.CUB  \nCutiile de împacheta t jucări ile implementeaz ă următoa rea interfață : \npackage cutii; \n \npublic interface ICutie { \n    public static double pretUnitateDeSuprafata = 0.05; \n    public static double lnod=20;  \n \n    abstract publi",
    "e implementeaz ă următoa rea interfață : \npackage cutii; \n \npublic interface ICutie { \n    public static double pretUnitateDeSuprafata = 0.05; \n    public static double lnod=20;  \n \n    abstract public double getSuprafataTotala (); \n    abstract public double getLungimePanglica (); \n \n    public default double pret(){ \n        return getSuprafataTotala()* pretUnitateDeSuprafata ; \n    } \n} \nToate dimensiunile se consider ă în cm, iar preț urile unitare sunt pe cm2 pentru costul cutiei sau pe \ncm pentru costul panglicii.  \nLungimea panglicii care ar putea orna cutia se calculeaz ă după dimensiunile cutiei tin ând cont de \nurmătoa rele: \n- pentru  o cutie cilindric ă – lungimea este cea necesara pentru a înfășura  de 2 ori cutia  în jurul \nsuprafețe i laterale ; data fiind prezenta constantei 3.14159… lungimea calculat ă a panglicii \npentru cutiile cilindrice va fi rotunjit ă la o valoare fără zecimale;  \n- pentru cutiile de forma  paralelipipedic ă lungimea este 2*(L+h) + 2*(l+L) , unde",
    "i 3.14159… lungimea calculat ă a panglicii \npentru cutiile cilindrice va fi rotunjit ă la o valoare fără zecimale;  \n- pentru cutiile de forma  paralelipipedic ă lungimea este 2*(L+h) + 2*(l+L) , unde l, L, h sunt cele \n3 dimensiuni date prin constructorul paralelipipedului ; similar și pentru cutiile cubice.  \nIndiferent de forma cutiei la lungimea calculat ă se adaugă  lnod= 20 cm pentru realizarea nodului \ndecorativ.  \nConfecționarea cutiilor  \nMagazinul are un dispozitiv special de confecționat  cutii la comanda de forma  și dimensiunile cutiilor \nrecomandate pentru fiecare jucări e. Acest dispozitiv va fi modelat  în program prin clasa Fabrica Cutii \ncare conține  o singură metodă statică ce primește  o referință  către o jucări e și returnează  cutia \nrecomandată  pentru acea jucări e: \n \n \nCe design pattern   veți utiliza p entru realizarea acestei clase ? \n\nPanglica  \nIn magazin e xistă operațională o singură rolă de panglic ă care inițial  are 100 00 cm  și din care \ntaie toți",
    "e: \n \n \nCe design pattern   veți utiliza p entru realizarea acestei clase ? \n\nPanglica  \nIn magazin e xistă operațională o singură rolă de panglic ă care inițial  are 100 00 cm  și din care \ntaie toți vânzătorii . Rola este caracterizat ă de costUnitateLungime  (0.01 lei/cm) și disponibil  \n(lungimea care a rămas  în rola; inițial  10000).  \nAtunci  când se cumpără o anumit ă lungime de panglic ă se verific ă dacă lungimea cerut ă este \nmai mic ă sau egal ă cu disponibil . Dacă este mai mare nu se d ă curs comenzii de cumpăr are (nu se \npoate cumpăr a o lungime mai mic ă decât cea necesar ă pentru a orna o anumit ă cutie).  \nCe design pattern veți folosi pentru clasa RolaPanglica  ? \nCumpăr area unui cadou  \nAceast ă acțiune  presupune realizarea unui Pachet  constituit din jucări e și, funcți e de ce a cerut \ncumpăr ătorul, cutie  și panglică. Clasa Pachet o veți realiza potrivit structurii următoa re: \n \nTEMA DE REALIZAT  \n1.",
    "pune realizarea unui Pachet  constituit din jucări e și, funcți e de ce a cerut \ncumpăr ătorul, cutie  și panglică. Clasa Pachet o veți realiza potrivit structurii următoa re: \n \nTEMA DE REALIZAT  \n1. (1p) Diagrama UML ( 0.5p  dacă este întocmit ă în timpul laboratorului)  \n2. (7p) Veți realiza a plicați a sub forma a 3 pachete ca  în figura următoa re: \n \n\nSe recomand ă dezvoltarea  în etape succesive a claselor  (“code a little, t est a little ”). Punctajul \nde 7 p . va fi acordat astfel:  \n• pentru realizarea pachetului cutii  veți primi 2p.,  \n• pentru pachetul jucări i 2p,  \n• clasa FabricaCutii  – 1p,  \n• clasa RolaPanglica  – 1p  \n• clasa Pachet  – 1p \nIn clasa Magazin  veți scrie o metodă main () care va testa clasele  și pachetele amintite anterior. Spre \nexemplu, p entru testarea clasei Pachet  veți insera secven ța următoa re: \n \n \nSystem.out.println( \"\\n===== Demo Pachet (1p) =====\" ); \nPachet p1 = new Pachet(new Minge(10), true, true); \nSystem.out.println( p1); \nSystem.out",
    "clasei Pachet  veți insera secven ța următoa re: \n \n \nSystem.out.println( \"\\n===== Demo Pachet (1p) =====\" ); \nPachet p1 = new Pachet(new Minge(10), true, true); \nSystem.out.println( p1); \nSystem.out.println( \"Pret=\"+p1.pretPachet());  \n \n \nPentru a primi punctajul trebuie ca rezultatul produs de program  să fie următor ul  \n \n===== Demo Cutii (2p) =====  \n[Cutie - Paralelipiped{l=10.0, L=20.0, h=30.0}, Cutie - Cub{l=40.0}, \nCutie-Cilindru{r=50.0, h=60.0}]  \n \n===== Demo Jucarii (2p) =====  \n[{Avion, cutie recomandata:PARALELIPIPED, l1=15.0, l2=25.0, l3=35.0}, \n{Minge, cutie recomandata:CUB, l1=45.0}, {Racheta, cutie \nrecomandata:CILINDRU, l1=55.0, l2=65.0}]  \n \n===== Demo Fabrica de cutii (1p) =====  \nPentru jucaria:{Avion, cutie recomandata:PARALEL IPIPED, l1=15.0, l2=25.0, \nl3=35.0}  \n cutia:Cutie - Paralelipiped{l=15.0, L=25.0, h=35.0}  \nPentru jucaria:{Minge, cutie recomandata:CUB, l1=45.0}  \n cutia:Cutie - Cub{l=45.0}  \nPentru jucaria:{Racheta, cutie recomandata:CILINDRU, l1=55.",
    "cutia:Cutie - Paralelipiped{l=15.0, L=25.0, h=35.0}  \nPentru jucaria:{Minge, cutie recomandata:CUB, l1=45.0}  \n cutia:Cutie - Cub{l=45.0}  \nPentru jucaria:{Racheta, cutie recomandata:CILINDRU, l1=55.0, l2=65.0}  \n cutia:Cutie -Cilindru{r=55.0, h=65.0}  \n \n===== Demo Panglica (1p) =====  \nPentru cutia:Cutie - Paralelipiped{l=10.0, L=20.0, h=30.0} necesar \nlung_panglica=:180.0  \n     dupa cumparare: {RolaPanglica, disponibil=9820.0}  \nPentru cutia:Cutie  - Cub{l=40.0} necesar lung_panglica=:340.0  \n     dupa cumparare: {RolaPanglica, disponibil=9480.0}  \nPentru cutia:Cutie -Cilindru{r=50.0, h=60.0} necesar lung_panglica=:648.0  \n     dupa cumparare: {RolaPanglica, disponibil=8832.0}  \n \n===== Demo Pachet (1p) =====  \nPachet{jucarie={Minge, cutie recomandata:CUB, l1=10.0}, impachetat in \nCutie - Cub{l=10.0}, lungPanglica=100.0}  \nPret=81.0  \n \nPentru Demo cutii  și Demo jucării se pot  utiliza tablouri care  să fie apoi afișate  cu metoda \nArrays.toString ( tablou  ).",
    ", impachetat in \nCutie - Cub{l=10.0}, lungPanglica=100.0}  \nPret=81.0  \n \nPentru Demo cutii  și Demo jucării se pot  utiliza tablouri care  să fie apoi afișate  cu metoda \nArrays.toString ( tablou  ). \n IMPORTANT  \n1. Metodele toString() utilizate trebuie  să producă  obligatoriu  același  format de \nieșire  ca cel exemplificat mai sus. Nestructurarea a plicați ei pe 3 pachete se \ndepuncteaz ă cu 1p. Codul redundant se depuncteaz ă cu pana la 2p.  \n \n \n3. (2p.) Completați  clasa Magazin  astfel  încât  să înregistreze  toate Pachetele \nvândute  într-o lista de vânzări , să le afișeze  și să calculeze valoarea total ă încasată . \nSugestie.  în clasa Magazin  vânzările  vor fi înregistrate  în \nArrayList<Pachet> listaVanzari;  \n \nFuncți a main()  din clasa Magazin  se va complet a cu secvența  următoa re: \n \nSystem.out.println( \"\\n===== Demo Magazin (2p) =====\" ); \nMagazin m = new Magazin();  \nList<Pachet> vanzari = m.getListaVanzari();  \nvanzari.add( new Pachet(new Minge(10), true, true",
    "a  următoa re: \n \nSystem.out.println( \"\\n===== Demo Magazin (2p) =====\" ); \nMagazin m = new Magazin();  \nList<Pachet> vanzari = m.getListaVanzari();  \nvanzari.add( new Pachet(new Minge(10), true, true) ); \nvanzari.add( new Pachet(new Minge(10), true, false) ); \nvanzari.add( new Pachet(new Minge(10), true, true) ); \nvanzari.add( new Pachet(new Minge(10), false, false) ); \nvanzari.add( new Pachet(new Racheta( 10,20), false, false) ); \nvanzari.add( new Pachet(new Avion(10,20, 30), false, false) ); \nvanzari.add( new Pachet(new Avion(10,20, 30), true, false) ); \nm.afisVanzari();  \nSystem.out.println( \"In rola au mai ramas \" +  \n               RolaPanglica .getRola().getDisponibil()+ \" cm\"); \n \n \nRezu ltatul execuției  trebuie  să fie următor ul: \n===== Demo Magazin (2p) =====  \nVanzari efectuate  \n1. Pachet{jucarie={Minge, cutie recomandata:CUB, l1=10.0}, impachetat in \nCutie - Cub{l=10.0}, lungPanglica=100.0}  \nPret=81.0  \n2.",
    "fie următor ul: \n===== Demo Magazin (2p) =====  \nVanzari efectuate  \n1. Pachet{jucarie={Minge, cutie recomandata:CUB, l1=10.0}, impachetat in \nCutie - Cub{l=10.0}, lungPanglica=100.0}  \nPret=81.0  \n2. Pachet{jucarie={Minge, cutie recomandata:CUB,  l1=10.0}, impachetat in \nCutie - Cub{l=10.0}}  \nPret=80.0  \n3. Pachet{jucarie={Minge, cutie recomandata:CUB, l1=10.0}, impachetat in \nCutie - Cub{l=10.0}, lungPanglica=100.0}  \nPret=81.0  \n4. Pachet{jucarie={Minge, cutie recomandata:CUB, l1=10.0}}  \nPret=50.0  \n5. Pachet{jucarie={Racheta, cutie recomandata:CILINDRU, l1=10.0, \nl2=20.0}}  \nPret=120.0  \n\n6. Pachet{jucarie={Avion, cutie recomandata:PARALELIPIPED, l1=10.0, \nl2=20.0, l3=30.0}}  \nPret=100.0  \n7. Pachet{jucarie={Avion, cutie recomandata:PARALELIPIPED, l1=10.0, \nl2=20.0, l3=30.0}, impachetat in Cutie - Paralelipiped{l=10.0, L=20.0, \nh=30.0}}  \nPret=210.0  \n \nSuma totala incasata=722.0  \nIn rola au mai ramas 8532.0 cm  \n \nTEMA ACASA  \n \nDacă aplicați a este complet funcți onal ă atunci",
    "tat in Cutie - Paralelipiped{l=10.0, L=20.0, \nh=30.0}}  \nPret=210.0  \n \nSuma totala incasata=722.0  \nIn rola au mai ramas 8532.0 cm  \n \nTEMA ACASA  \n \nDacă aplicați a este complet funcți onal ă atunci  în clasa Magazin  scrieți  următoa rele metode : \n1. afisPacheteDupa Preț( boolean descrescator ) - care afișează  toate pachetele  în \nordinea descrescătoare   (dacă descrescator  =true ) sau crescătoare  (dacă descrescator  =false ) \na preț ului lor  (2p)  \n2. cautaPachet(Pachet x) care caută  în lista de vânzări  dacă exista un  pachet cu același  \nconținut  ca și pachetul x. Metoda va întoarce  indexul pachetului din lis ta de vânzări  sau -1 \ndacă nu exist ă un astfel de pachet   (2p) \n3. citesteVanzari(String numeFisier) – care preia d intr-un fișier  text comenzile  \nefectuate într-o anumit ă perioad ă (putem  presupune o a plicați e de comer ț electronic care \npreia fișierul  cu toate comenzile făcute  online) pregătește  pachetele cu jucări i, cutiile  și  \npanglicile care se ce",
    "anumit ă perioad ă (putem  presupune o a plicați e de comer ț electronic care \npreia fișierul  cu toate comenzile făcute  online) pregătește  pachetele cu jucări i, cutiile  și  \npanglicile care se cer conform comenzii f ăcute. La sfârșit  se afișează  vanz ările potrivit \ninformațiilor di n fișierul  citit. Fi șierul are una sau mai multe linii, pe fiecare linie fiind trei șiruri:  \n \nnumele_ jucăriei  DA_sau_NU_cutie  DA_sau_NU_panglica  \nExemplu  \nMinge da DA  \nMinge da nu  \nMinge da    da \nMinge   NU   nu \nRachetA     nu nu \nAVION NU  NU \nAvion da   nu \nSe va considera că dimensiunile jucăriilor sunt cele utilizate pentru secvența  de exemplificare \na vânzărilor din  ===Demo Magazin ===.    (2p). \n \n4. Implementați următoarea strategie în clasa RolaPanglica : atunci când rola s -a epuizat (când la \nprima cerere lungimea panglicii solicitate este mai mică decât disponibilul) să fie adusă una \nnouă (i.e. să se creeze un nou obiect unic). (1p)",
    "zat (când la \nprima cerere lungimea panglicii solicitate este mai mică decât disponibilul) să fie adusă una \nnouă (i.e. să se creeze un nou obiect unic). (1p)",
    "Laborator 5  – Liste  \n \nTema de realizat  \n1. Pe pagina cursului, deschideti materialul Exemplu  lista, tip generic, Iterator,  Iterable (PDF)  \n2. Creati un proiect Lab5 in care sa includeti intregul pachet listadiamant  \n3. (1p) In clasa ListaGenerica  introduceti o functie noua size() care sa dea numarul de elemente din \nlista. Complexitatea acestei metode trebuie sa fie O(1).  \nIn functia main() din clasa AplicatieLista  adaugati cod care sa produca afisarea  \nOrasele din lista:Suceava Bucuresti Iasi  \nNumerele din lsta:19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nIntregii din lsta  x10: 190, 170, 150, 130, 110, 90, 70, 50, 30, 10, 0, 20, 40, 60, \n80, 100, 120, 140, 160, 180, 200,  \nLungimea listei este 21  \n \n4.  (1.5p) Adaugati o clasa noua ListaGenerica2<T>  care sa extinda ListaGenerica<T>  si care sa \nimplementeze metoda public T eliminaP rimul();  \nIn functia main() din clasa AplicatieLista  adaugati cod care sa produca afisarea urmatoare  \nOrasele din lista:Suceav",
    "da ListaGenerica<T>  si care sa \nimplementeze metoda public T eliminaP rimul();  \nIn functia main() din clasa AplicatieLista  adaugati cod care sa produca afisarea urmatoare  \nOrasele din lista:Suceava Bucuresti Iasi  \nNumerele  din lsta:19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nIntregii din lsta x10: 190, 170, 150, 130, 110, 90, 70, 50, 30, 10, 0, 20, \n40, 60, 80, 100, 120, 140, 160, 180, 200,  \nLungimea listei este 21  \n \n================ Demo eliminaPrimul() =========== ======= \nNumerele din lista(21): 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(20): 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(19): 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(18):  13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(17): 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(16): 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(15): 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele",
    "umerele din lista(17): 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(16): 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(15): 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(1 4): 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(13): 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(12): 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(11): 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(10): 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(9): 4 6 8 10 12 14 16 18 20  \nNumerele din lista(8): 6 8 10 12 14 16 18 20  \nNumerele din lista(7): 8 10 12 14 16 18 20  \nNumerele din lista(6): 10 12 14 16 18 20  \nNumerele din lista(5): 12 14 16 18 20  \nNumerele din lista(4): 14 16 18 20  \nNumerele din lista(3): 16 18 20  \nNumerele din lista(2): 18 20  \nNumerele din lista(1): 20  \nNumerele din lista(0):  \n \n5. (1.5p) In clasa ListaGenerica2<T>  includeti metoda public T eliminaUltimul();  Inserati cod in \nmain() astfel incat sa se produca dupa afisare",
    "umerele din lista(1): 20  \nNumerele din lista(0):  \n \n5. (1.5p) In clasa ListaGenerica2<T>  includeti metoda public T eliminaUltimul();  Inserati cod in \nmain() astfel incat sa se produca dupa afisarea de mai sus urmatorul rezultat:  \n \n================ Demo eliminaUltimul() ==================  \nNumerele din lista(21): 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(20): 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18  \nNumerele din lista(19): 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16  \nNumerele din lista(18): 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14  \nNumerele din lista(17): 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12  \nNumerele din lista(16): 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10  \nNumerele din lista(15): 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8  \nNumerele din lista(14): 19 17 15 13 11 9 7 5 3 1 0 2 4 6  \nNumerele din lista(13): 19 17 15 13 11 9 7 5 3 1 0 2 4  \nNumerele din lista(12): 19 17 15 13 11 9 7 5 3 1 0 2  \nNumerele din lista(11): 19 17 15 13 11 9 7",
    "lista(14): 19 17 15 13 11 9 7 5 3 1 0 2 4 6  \nNumerele din lista(13): 19 17 15 13 11 9 7 5 3 1 0 2 4  \nNumerele din lista(12): 19 17 15 13 11 9 7 5 3 1 0 2  \nNumerele din lista(11): 19 17 15 13 11 9 7 5 3 1 0  \nNumerele din lista(10): 19 17 15 13 11 9 7 5 3 1  \nNumerele din lista(9): 19 17 15 13 11 9 7 5 3  \nNumerele din lista(8): 19 17 15 13 11 9 7 5  \nNumerele din lista(7): 19 17 15 13 11 9 7  \nNumerele din lista(6): 19 17 15 13 11 9  \nNumerele din lista(5): 19 17 15 13 11  \nNumerele din lista(4): 19 17 15 13  \nNumerele din lista(3): 19 17 15  \nNumerele din lista(2): 19 17  \nNumerele din lista(1): 19  \nNumerele din lista(0):  \n \n6. (1p) Adaugati cod in functia main() din clasa AplicatieLi sta cod care sa produca in continuare si \nafisarea urmatoare:  \n \n================ Demo elimina Primul si Ultimul alternativ =======================  \nNumerele din lista(21) <init> 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista( 20) <19>  :17 15 13 11 9 7 5 3 1 0 2 4 6 8 1",
    "ul si Ultimul alternativ =======================  \nNumerele din lista(21) <init> 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista( 20) <19>  :17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20  \nNumerele din lista(19) <20>  :17 15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18  \nNumerele din lista( 18) <17>  :15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18  \nNumerele din lista(17) <18>  :15 13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16  \nNumerele din lista(16) <15>  :13 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16  \nNumerele din lista(15) <16>  :13 11 9 7 5 3 1 0 2 4 6 8 10 12 14  \nNumerele din lista(14) <13>  :11 9 7 5 3 1 0 2 4 6 8 10 12 14  \nNumerele din lista(13) <14>  :11 9 7 5 3 1 0 2 4 6 8 10 12  \nNumerele din lista(12) <11>  :9 7 5 3 1 0 2 4 6 8 10 12  \nNumerele din lista(11) <12>  :9 7 5 3 1 0 2 4 6 8 10  \nNumerele din li sta(10) <9>  :7 5 3 1 0 2 4 6 8 10  \nNumerele din lista(9) <10>  :7 5 3 1 0 2 4 6 8  \nNumerele din lista(8) <7>  :5 3 1 0 2 4 6 8  \nNumerele din lista(7) <8>  :5",
    "7 5 3 1 0 2 4 6 8 10  \nNumerele din li sta(10) <9>  :7 5 3 1 0 2 4 6 8 10  \nNumerele din lista(9) <10>  :7 5 3 1 0 2 4 6 8  \nNumerele din lista(8) <7>  :5 3 1 0 2 4 6 8  \nNumerele din lista(7) <8>  :5 3 1 0 2 4 6  \nNumerele din lista(6) <5>  :3 1 0 2 4 6  \nNumerele din lista(5) <6>  :3 1 0 2 4  \nNumerele din lista(4) <3>  :1 0 2 4  \nNumerele din lista(3) <4>  :1 0 2  \nNumerele din lista(2) <1>  :0 2  \nNumerele din lista(1) <2>  :0  \nNumerele din lista(0) <0>  :  \n \n7. (3p) Crea ți o nou ă clasă ListGenerica<T>  care să implementeze interfa ța java.util.List  \nVeți implementa acele metode  din interfa ța List<T> care fac posibil ă execu ția metodelor din \nclasa TestList.  Veți crea un pachet nou testlist  în care ve ți introduce clasa TestList . \nVeti evalua cu clasa TestList  comparativ durata de execu ție a celor 3 implement ări ale \ninterfe ței List<T>  \n• ListGenerica<T>  \n• LinkedList<T>  \n• ArrayList<T>  \n \nClasa TestList  \npackage testlist;  \n \nimport java.util.ArrayList;  \nimpor",
    "rata de execu ție a celor 3 implement ări ale \ninterfe ței List<T>  \n• ListGenerica<T>  \n• LinkedList<T>  \n• ArrayList<T>  \n \nClasa TestList  \npackage testlist;  \n \nimport java.util.ArrayList;  \nimport java.util.LinkedList;  \nimport java.util.List;  \nimport listadiamant.ListGenerica;  \n/** \n * @author St.Gh. PENTIUC  \n */ \npublic class TestList {  \n \n    private static String FORMAT=\"%d\";  \n    static int N = 100000, Nafisate=10;  \n    public static void main(String[] args) {  \n        List<Integer> lst1 = new ArrayList<>();  \n        List<Integer> lst2 = new LinkedList<>();  \n        List<Integer> lst3 = new Li stGenerica<>();  \n        List liste[] = new List[]{lst3, lst2, lst1};  \n        for(List lst:liste){  \n            System.out.println(\" \\n================= Demo \"   \n                               + lst.getClass().getSimpleName()  \n                               + \" =====================\");  \n            System.out.printf(\"%s \\n\", lst.toString() ); \n            testInserari(ls",
    "+ lst.getClass().getSimpleName()  \n                               + \" =====================\");  \n            System.out.printf(\"%s \\n\", lst.toString() ); \n            testInserari(lst);  \n            testEliminari(lst , true);  // sau false fara if(..contains(x).. \n        } \n    } \n    static void  testInserari(List<Integer> lst) {  \n      int nrerori = 0;  \n        int x, y;  \n        long startTime = System.currentTimeMillis();  \n        System.out.printf( \"Start inserari (i - in fata, I - la urma): \\n\"); \n        for (x  = 0; x<N ;    x += 1){  \n            if (x > N / 2) {  \n                    lst.add(0, x);  \n                if ((y = lst.get(0) ) != x) {  \n                   System.out.printf(\" \\n***Eroare. S -a inserat \"+FORMAT  \n                                        +\" s-a gasit \"+FORMAT, x, y);  \n                   nrerori++;  \n            } \n        } else { \n            lst.add(x);  //inserare la urma  \n            if ((y = lst.get( lst.size() -1 )) != x",
    "+\" s-a gasit \"+FORMAT, x, y);  \n                   nrerori++;  \n            } \n        } else { \n            lst.add(x);  //inserare la urma  \n            if ((y = lst.get( lst.size() -1 )) != x) {  \n                System.out.printf(\" \\n***Eroare. S -a inserat \"+FORMAT  \n                                +\" s-a gasit \"+FORMAT, x, y);  \n                nrerori++;  \n            } \n        } \n        if (N > Nafisate)  \n  \n            if ((int) x % 1000 == 0) {  \n                System.out.printf(\"%c\", x > N / 2 ? 'i' : 'I');  \n            } \n        if (N <= Nafisate)  \n             System.out.printf(\" \\ni=%d %s \\n\", x, lst);      \n    } \n \n    if(lst.size() !=N) \n        System.out.printf(\"***Eroare. In lista ar trebui sa fie \" \n                          +\" %d elemente\",N);  \n    System.out.printf(\" \\nLista are %d elemente.\", lst.size());  \n    System.out.printf(\" \\nTest inserare incheiat cu %d erori \\n\", nrerori);  \n    afisDurataExecutie(startTime);  \n     \n} \n    static void afi",
    "m.out.printf(\" \\nLista are %d elemente.\", lst.size());  \n    System.out.printf(\" \\nTest inserare incheiat cu %d erori \\n\", nrerori);  \n    afisDurataExecutie(startTime);  \n     \n} \n    static void afisDurataExecutie(long startTime){  \n        long durata = System.currentTimeMillis() - startTime;  \n        System.out.printf(\"Durata test %.3f s \\nDurata per element\"  \n                          + \" %.6f ms\\n\\n\", \n                        (float)(durata/1000.), (float)(durata/(double)N));  \n    } \n   static void testEliminari(List<Integer> lst ,  \n                            boolean  verificaSiContinut ){ \n        int nrerori=0;  \n        int x=N;  \n        long startTime = System.currentTimeMillis();  \n        System.out.printf(\" \\nStart eliminari (d - primul, D -\" \n                          + \" ultimul element): \\n\"); \n        while(!lst.isEmpty()) {  \n           x--; \n           if (N<=Nafisate)  \n               System.out.printf(\" \\nlst(%d elemente): \", lst.size(), lst);  \n \n        if(",
    "\" ultimul element): \\n\"); \n        while(!lst.isEmpty()) {  \n           x--; \n           if (N<=Nafisate)  \n               System.out.printf(\" \\nlst(%d elemente): \", lst.size(), lst);  \n \n        if(verificaSiContinut  && lst.contains(x) ==false){  \n           System.out.printf( \" \\n*** Eroare inserare info=\"+FORMAT  \n                            + \"In lista %s sunt % d elemente\",x,  \n                                      ((Object)lst), lst.size());  \n           nrerori++;  \n        } \n        if(x>N/2)  \n            lst.remove(0) ; \n        else \n            lst.remove( lst.size() -1 ); \n        if(verificaSiContinut  && lst.contains(x)!=false) {  \n            System.out.printf(\" \\n*** Eroare stergere info=\"+FORMAT  \n                             + \"In lista %s sunt %d elemente\",  \n                               x, lst, lst.size());  \n            nrerori++;  \n        } else {  \n           if (N<=Nafisate)  \n              System.out.printf(\" S -a eliminat \"+FORMAT+\" (lst a ramas %s)\",",
    "x, lst, lst.size());  \n            nrerori++;  \n        } else {  \n           if (N<=Nafisate)  \n              System.out.printf(\" S -a eliminat \"+FORMAT+\" (lst a ramas %s)\",  \n                                  x, lst);  \n           else \n              if((int)x%1000==0)  \n                  System.out.printf(\"%c\", x>N/2 ? 'd':'D');  \n        } \n       } \n       System.out.printf(\" \\nTest eliminare incheiat cu %d erori \\n\",  \n                                                          nrerori);  \n       afisDurataExecutie(startTime);  \n     \n    } \n} \n \nComparati performantele clasei realizate la curs si laborator cu performantele celor 2 clase din \npachetul java.util.  Veti face 2 execuții  \n- una în care testele de remove() au verificat cu contains()  conținutul  listel or înainte și după \nremove()  \n- altă execuție în care se vor efcetua doar operații de remove() fără verificarea cu co ntains (); \nîn acest scop , în metoda main() din clasa TestList  veți apela t",
    "tel or înainte și după \nremove()  \n- altă execuție în care se vor efcetua doar operații de remove() fără verificarea cu co ntains (); \nîn acest scop , în metoda main() din clasa TestList  veți apela testEliminari(lst , false);  \n  \nUn exemplu de execu ție în care testele de remove() au verificat cu contains() listele este \nurmatorul:  \n================= Demo ListGenerica =====================  \n \nStart inserari (i - in fata, I - la urma):  \nIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIiiiiiiiiiiiiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiiii  \nLista are 1000 00 elemente.  \nTest inserare incheiat cu 0 erori  \nDurata test 0,028 s  \nDurata per element 0,000280 ms  \n \n \nStart eliminari (d - primul, D - ultimul element):  \ndddddddddddddddddddddddddddddddddddddddddddddddddDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\nDDDDDDDDDDDDDDDDDDDD  \nTest eliminare incheiat cu 0 erori  \nDurata test 15,298 s  \nDurata per element 0,152980 ms  \n \n \n================= Demo LinkedList =====================  \n[] \nStart inse",
    "DDDDDDD\nDDDDDDDDDDDDDDDDDDDD  \nTest eliminare incheiat cu 0 erori  \nDurata test 15,298 s  \nDurata per element 0,152980 ms  \n \n \n================= Demo LinkedList =====================  \n[] \nStart inserari (i - in fata, I - la urma):  \nIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIiiiiiiiiiiiiiii iiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiiii  \nLista are 100000 elemente.  \nTest inserare incheiat cu 0 erori  \nDurata test 0,015 s  \nDurata per element 0,000150 ms  \n \n \nStart eliminari (d - primul, D - ultimul element):  \ndddddddddddddddddddddddddddddddddddddddddddddddddDDDDDDDD DDDDDDDDDDDDDDDDDDDDDDD\nDDDDDDDDDDDDDDDDDDDD  \nTest eliminare incheiat cu 0 erori  \nDurata test 13,148 s  \nDurata per element 0,131480 ms  \n \n \n================= Demo ArrayList =====================  \n[] \nStart inserari (i - in fata, I - la urma):  \nIIIIIIIIIIIIIIIIIIIIIII IIIIIIIIIIIIIIIIIIIIIIIIIIIIiiiiiiiiiiiiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiiii  \nLista are 100000 elemente.",
    "=================  \n[] \nStart inserari (i - in fata, I - la urma):  \nIIIIIIIIIIIIIIIIIIIIIII IIIIIIIIIIIIIIIIIIIIIIIIIIIIiiiiiiiiiiiiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiiii  \nLista are 100000 elemente.  \nTest inserare incheiat cu 0 erori  \nDurata test 0,350 s  \nDurata per element 0,003500 ms  \n \n \nStart eliminari (d - primul, D - ultimul element):  \ndddddddddddddddddddddddddddddddddddddddddddddddddDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\nDDDDDDDDDDDDDDDDDDDD  \nTest eliminare incheiat cu 0 erori  \nDurata test 4,863 s  \nDurata per element 0,048630 ms  \n \n \n \n8. (2p) Cautati o solutie care sa obtina timpi mai mici de executie la functia de eliminare a \nelementelor din lista.  Pentru a fi mai putin influentati de platforma concreta pe care se executa \nprogramul veti imparti timpul de executie al fiecarei clase la timpul obtinut cu LinkedList . Veti \ncomplet a un tab el ca cel  care urmeaza:  \n ListGenerica  LinkedLi st ArrayList  Clasa \ndv.",
    "xecuta \nprogramul veti imparti timpul de executie al fiecarei clase la timpul obtinut cu LinkedList . Veti \ncomplet a un tab el ca cel  care urmeaza:  \n ListGenerica  LinkedLi st ArrayList  Clasa \ndv. \nTimpi test remove (cu contains)  15,298  13,148  4,863    \nRaportat la LinkedList  1,164  1 0,370    \nTimpi test remove (fara contains)  2,360  0,009  0,337    \nRaportat la LinkedList  262,222  1 37,444    \n \nS-au folosit pentru primele clase datele din exemplul anterior. Dv. veti trece timpii obtinuti pe \ncalculatorul dv.  \n \nExplicati  \n- de ce durata testelor de remove() care utilizeaza contains() sunt aprop iate in cazul claselor \nListGenerica  si LinkedList  \n- diferenta foarte mare în cazul teste lor de remove () efectate f ără contains(x) între \nListGenerica  si LinkedList  și între ArrayList  si LinkedList  \n \nTemă acasă   \n1. Reproiect ați aplicatia astfel încât ListGenerica  să aibă durate appropriate  cu \nLinkedList   la teste le de remove() și i nsert()  fără a utiliza contai",
    "rrayList  si LinkedList  \n \nTemă acasă   \n1. Reproiect ați aplicatia astfel încât ListGenerica  să aibă durate appropriate  cu \nLinkedList   la teste le de remove() și i nsert()  fără a utiliza contains( ) în cadrul testelor \n(5p). \n2. Implementați complet interfața List și scrieți un program de test  în care să utilizați \ntoate funcțiile  (10p).",
    "Laborator 6 \n \nTest  \n \nSubiectele contin o parte din cele 5 lucrari de laborator efectuate.  Practic sunt 5 \nvariante de test, fiecare varianta fiind axata pe una din cele 5 lucrari de laborator . \nPunctajul la test: 1p din oficiu, 5p din exercitii din lucrarea de laborator  efect uata, 4p \nexerci tii noi care dezvolta/continua subiectele avute la laborator.  \n \nCele 4 puncte pentru exercitii noi din fiecare varianta de test se acorda pentru:  \n1p – o dezvoltare (clasa noua care sa extinda o clasa existenta, metode noi)  \n1p – metoda indexOf(…)  \n1p – o sortare potrivit unui criteriu (ordin ea natural a, interfata  Comparable)  \n1p – o sortare care sa foloseasca un obiect de tip Comparator  \n \n \nExemplu; Pentru varianta de test axata pe Laborator 1 se cer pentr u cele 4 p \nurmatoarele:  \n1p – o clasa care sa extinda clasa Punct su Po ligon \n \n3p - Scrieti urmatoarele metode in clasa Poligon  \na) (1p) indexOf(Punct p)  – returneaza indicele varfului egal cu p, sau -1 daca p \nnu este pr",
    "1p – o clasa care sa extinda clasa Punct su Po ligon \n \n3p - Scrieti urmatoarele metode in clasa Poligon  \na) (1p) indexOf(Punct p)  – returneaza indicele varfului egal cu p, sau -1 daca p \nnu este printre varfurile poligonului; exemplu  \nInt ind = polig.indexOf( new Punct(3.0, 3.0));  \nSe vor prezenta 4 cazuri; p este varful cu indicele 0, p un varf cu un indice intermediar, \np este ultimul varf, p nu este printre varfurile poligonului  \nb) (2p) o functie afisSortVarfuri  (boolean dupaX)  care va afisa tabloul \nvarfurilor sortat  crescator  dupa coordonata x (daca variabila dupaX  are valoarea true) \nsau sortat crescator dupa coordonata y (daca dupaX=false)  \nNota. Daca functia nu foloseste o metoda sort( ) din API Java se depuncteaza cu 1p . \n \nCea mai buna pregatire pentru test este efectuarea in intregime \na tuturor lucrarilor . \n \nS u c c e s !",
    "ctuarea in intregime \na tuturor lucrarilor . \n \nS u c c e s !",
    "Laborator 7  \nDoua texte \ncifrate  \n \n \nUn student din anul III C alculatoare t ocmai a terminat de studiat materialul Aplicatie.Analiza unui  \ntext de la cursul de SD cand a primit un email de la p rietena lu i continand doua scurte fragmente  de \ntext cifrate  rugandu -l sa le de cifreze.   \nPrimul text , despre care i-a spus ca l -a gasit pe un forum , era  urmatorul:  \nKNJXH JXYJ T KFHZQYFYJ HFWJ YJ NSYJQJLJ XN YJ KFHJ XF NSYJQJLN.  \nRJWNYF XF -YN KFHN XYZINNQJ FNHN.  \n \nAl doilea  text i -a spus ca l -a cifrat ea pentru a -I testa perspicacitatea si abilitatile de programare:  \nwqwr pzkj qtpzgj zp -r eboqu  \nzrwr cbw inuj q wpzbqioj  \nrqu lujvjq rzwjquwq rz xqkqu  \nkrz gbcpur q ij zqioj  \nir krz q weqbipcpr lqr  \ntpu rvnujtpu kj irzj  \nljkjq wq -z xrpq wjq krzoqr  \nwpv rxlbuqp cpvrzj  \n \nStuden tul nostru stie ca pe forumuri mai apar texte cifrate cu o functie din Unix care implementeaz a \nalgoritmul cunoscut ca Cifrul lui Cezar , descris si pe Wikipedia.",
    "zoqr  \nwpv rxlbuqp cpvrzj  \n \nStuden tul nostru stie ca pe forumuri mai apar texte cifrate cu o functie din Unix care implementeaz a \nalgoritmul cunoscut ca Cifrul lui Cezar , descris si pe Wikipedia.  \nA scris o clasa si a reusit sa -l decifreze.  \nCunoscand ca prietena lui nu a facut cursuri de criptare, cu m de  altfel nici e l nu a fac ut, a banuit ca \nprietea sa a inlocuit literele alfabetului cu alte litere, la intamplare.  \nA analizat textele emailurilor pe care le -a primit de la ea si a gasit ca frecventele literelor cu care \nerau scrise sunt umatoarele : \n\nA = 15.09%  I = 13.21%  E = 10.06%  N = 10.06%  U = 8.18%  R = 6.92%  C = 5.03%  S = 4.40%  D = \n4.40%  O = 4.40%  L = 3.77%  V = 3.77% T = 2.52%  M = 1.89%  J = 1.26%  Z = 1.26%  H = 1.26%  G = \n1.26 %  P = 1.26%    \nA analizat cu programul dat la curs si al  doilea text cifrat primit, a mai adaugat un constructor la \nclasa deja facuta , a încercat cu frecvențele de mai sus  și … a decifrat si al doilea text.",
    "A analizat cu programul dat la curs si al  doilea text cifrat primit, a mai adaugat un constructor la \nclasa deja facuta , a încercat cu frecvențele de mai sus  și … a decifrat si al doilea text.  \nIncercati si dumneavoastra sa decifrati cele doua texte.   \nDumneavoastra mai sunteti ru gati sa  faceti  un program  Java in care obligatoriu  \na. sa fie comentarii in fiecare clasa cu numele autorului  \nb. sa foloseas ca cel putin o clasa din JCF  \nc. programul sa poata fi utilizat si pentru decifrarea unor texte memorate in fisiere text  \ncare au fost cifrate potrivit metodelor prezentate  \nPunctaj  \n3p – Clasa functionala pentru decifrarea primului text  \n3p - Decifrarea celui de -al doilea text  \n2p - Decifrarea unui fisier text cifrat prin prima metoda (rezultatul va fi un fisier cu textul decifrat)  \n2p - Decifrarea unui fisier text cifrat prin a doua  metoda (rezultatul va fi un fisier cu textul decifrat)  \n \nIndicatie.",
    "xt cifrat prin prima metoda (rezultatul va fi un fisier cu textul decifrat)  \n2p - Decifrarea unui fisier text cifrat prin a doua  metoda (rezultatul va fi un fisier cu textul decifrat)  \n \nIndicatie. Poate va este de folos codul urmator:  \npublic class Cifru {  \n    public static int lngAlfabet='Z' -'A'+1; \n         \n    public static String  Cezar(String text, int deplasare){  \n        StringBuilder rez= new StringBuilder();  \n        char ctext[]= text.toCharArray();  \n        char cmin;  \n        for(char c: ctext){  \n            if(Character.isLetter(c)){  \n                if(Character.isUpperCase(c))  \n                    cmin='A';  \n                else \n                    cmin='a';  \n                c = (char)((c -cmin+deplasare)% lngAlfabet + cmin);  \n            } \n            rez.append(c);  \n        } \n        return rez.toString();  \n    } \n}",
    "ez.append(c);  \n        } \n        return rez.toString();  \n    } \n}",
    "Lucrare de laborator 8.2 \n \nGestiunea unui magazin  \n \nScrieti o clas ă Produs  caracterizată in principal de codProdus, denumire, pret, cantitate . \nMai scrieti o clasă Magazin  în care să existe o struc tură  inventar  cu toate produsele existente în \nmagazin și în care acestea să se poată regăsi după codul lor. În această clasă se vor găsi cel puțin \nurmătoarele metode:  \n• int aprovizioneaza ( codProdus, q a ) -  verifică dacă există în inventar  un produs cu acest cod, \niar dacă există suplimentează  cantitatea din acest produs cu qa și returnează noua valoare a \ncantității, dacă nu există codProdus  în inventar  atunci returnează -1; dacă valoarea qa este \nnegativă  va fi transformată în una pozitivă;  \n• int aprovizioneaza ( codProdus, denumire, pret, qa)  - mai întâi verifică dacă există în inventar  \nun produs cu acest cod; dacă există nu efectuează alte prelucrări și va returna -1; dacă este un \ncod nou atunci va crea un obiect de tip Produs  si îl va în registra în inventar",
    "există în inventar  \nun produs cu acest cod; dacă există nu efectuează alte prelucrări și va returna -1; dacă este un \ncod nou atunci va crea un obiect de tip Produs  si îl va în registra în inventar ; dacă valorile \nnumerice ale parametrilor sunt negative le va transforma în valori pozitive ; \n• int vanzare ( codProdus, qv )  - verifică dacă există în inventar  un produs cu acest cod; dacă nu \nexistă returnează -1; dacă există va diminua cantitatea produsului cu valoarea qv (se va lua în \nconsiderare valoarea absolută a parametru lui qv); dacă qv este mai mare decât cantitatea \ndisponibilă se va vinde doar în cantitatea exis tentă; se va ac tualiza cantitatea existentă în \nmagazin din acest produs și se va returna cantitatea vândută ; \n• int vanzare ( codProdus  ) – aceeasi functie in care cantitatea este  1 \n• situatieV anzari()   care va afișa produsele existente în magazin  sub forma  \n \ncod  denumire  pret  cant itateExist.",
    "ă ; \n• int vanzare ( codProdus  ) – aceeasi functie in care cantitatea este  1 \n• situatieV anzari()   care va afișa produsele existente în magazin  sub forma  \n \ncod  denumire  pret  cant itateExist. cantitateVanduta   valoareVanzari  \n   101  TV        500   10              5                  2500  \n      . . . \n   Total valoare incasata din vanzari ….  \n \n• float situatieProdus  (codProdus)  care va afișa informațiile de mai sus privitoare numai la \nprodus ul cu codul codProdus  sau, dupa caz,  textul “ Nu exista in invent ar” și va returna val oarea  \nvânzărilor din acest produs sau -1 dacă nu există.  \nÎn metoda main()  veți crea  inițial  un invent ar cu cel putin 3 produse diferite și veți face apoi cel \npuțin 5 vânzări , încă 3 aprovizionări (una la un produs nou) și iarăși 2 vânzări afișând de fiecare dată \nsituatia prod usului,  cu exceptia ultimei operatii  dupa  care  veti afi sa situatia vanzarilor  la toate \nprodusele .",
    "provizionări (una la un produs nou) și iarăși 2 vânzări afișând de fiecare dată \nsituatia prod usului,  cu exceptia ultimei operatii  dupa  care  veti afi sa situatia vanzarilor  la toate \nprodusele . \nTemă acasă  \n1. Scrieti o funcție sau mai multe care să afiș eze situatia vânzărilor   \n- în ordinea descrescătoare a valorii vânzărilor , \n- în ordinea crescătoare a cantității existente  în magazine , \n- în ordinea crescătoare a codurilor de produs . \n \n2. Scrieti o functie care sa afiseze , in ordinea lexicografica a denumirii lor,  doar acele produse la \ncare s -au solicitat vanz ări si cantitatea nu a fost suficientă  (se va afisa codProdus si denumire).  \n \n3. Scrieti o metodă  situatieProdus  ( denumire  ) care să afișeze situația vânzărilor pentru toate \nprodusele care au această denumire  \n \nNota.  Utilizati structur ile de date  cele mai potrivite pentru re alizarea functiilo r cerute aplicatiei.",
    "umire  \n \nNota.  Utilizati structur ile de date  cele mai potrivite pentru re alizarea functiilo r cerute aplicatiei.",
    "Laborator 8  \nInmatriculare studenti  \n \nAplicatia are ca obiectiv familiarizarea cu clasele si interfetele din JCF.  \nSe va simula inmatricularea studentilor in universitate. Pentru a putea testa performantele cu un numar \nvariabil de studenti se va evita introducerea datelor, iar studentii vor putea fi generati automat.  \nFiecare student inmatriculat va fi inregistrat in  \n• Registrul matricol al Universitatii (fiecare student va primi un numar matricol de la 1 la n, iar \nregasirea studentului in Registrul matric ol va fi posibila cu ajutorul numarului matricol;  \n• colectivul de studenti ai facultatii; veti considera structura de facultati a USV  (FDSA, FEFS, FIA, \nFIESC, FIMM, FIG, FLSC, FS, FSEAP, FSE ); \n• registru l orientat pe gen care sa permita obtinerea listei tuturo r studentelor si a tuturor \nstudentilor.  \nSe va considera ca un student poate fi inscris o singura data in registrul matricol la aceeasi facultate ; se \nva verifica sa nu fie inscris in Registrul matricol un st",
    "or si a tuturor \nstudentilor.  \nSe va considera ca un student poate fi inscris o singura data in registrul matricol la aceeasi facultate ; se \nva verifica sa nu fie inscris in Registrul matricol un student cu acelasi nume, aceeasi medie si aceeasi \nfacultate (conditia ca 2 studenti sa fie egali) cu unul generat anterior.  \nPentru a genera studenti veti scrie in clasa Student  un constructor fara argumente care va genera date \nsimilar cu constructorul fara argumente al clasei Persoana .   \nAplicatia trebuie s a produca urmatoarea iesire (pentru 1p veti asigura neaparat testarea cu un student \nidentic cu altul generat anterior). In exemplul de mai jos s -au generat 9 studenti diferiti, al 6 -lea fiind \nidentic cu cel anterior.  \n//---------------------------  1p ----------------------------------    \nstud. Cosmin (M) , 8.99, FIA *** student deja inscris in Registrul matricol  \n \n//---------------------------  1p ----------------------------------    \nRaport \n- total in registru 9 student",
    "-----    \nstud. Cosmin (M) , 8.99, FIA *** student deja inscris in Registrul matricol  \n \n//---------------------------  1p ----------------------------------    \nRaport \n- total in registru 9 studenti  \n \n//---------------------------  2p ----------------------------------  \n- inmatriculati pe facultati  \n -FDSA : 0 studenti  \n -FEFS : 3 studenti  \n -FIA : 1 studenti  \n -FIESC : 0 studenti  \n -FIMM : 1 studenti  \n -FIG : 1 studenti  \n -FLSC : 1 studenti  \n -FS : 0 studenti  \n -FSEAP : 2 studenti  \n -FSE : 0 studenti  \n//---------------------------   2p ---------------------------     \nBaieti:4  \nFete  :5  \n//---------------------------   2p ---------------------------     \nPrimele 10 nr. matricole:  \n1. stud. Georgiana (F) , 7.72, FE FS \n2. stud. Iulia (F) , 5.22, FIG  \n3. stud. Maria (F) , 6.76, FSEAP  \n4. stud. Mirabela (F) , 8.58, FSEAP  \n5. stud. Cosmin (M) , 8.99, FIA  \n6. stud. Iulia (F) , 5.86, FEFS  \n7.",
    "iana (F) , 7.72, FE FS \n2. stud. Iulia (F) , 5.22, FIG  \n3. stud. Maria (F) , 6.76, FSEAP  \n4. stud. Mirabela (F) , 8.58, FSEAP  \n5. stud. Cosmin (M) , 8.99, FIA  \n6. stud. Iulia (F) , 5.86, FEFS  \n7. stud. Vladimir (M) , 5.19, FEFS  \n8. stud. Ion (M) , 5.81, FIMM  \n9. stud. Ion (M) , 5.65,  FLSC \n10. null  \n \n//---------------------------   2p ---------------------------     \nAlegeti facultatea(FDSA=1 FEFS=2 FIA=3 FIESC=4 FIMM=5 FIG=6 FLSC=7 FS=8 \nFSEAP=9 FSE=10  gata>=11): 4 \nNu sunt studenti inmtriculati  \nAlegeti facultatea(FDSA=1 FEFS=2 FIA=3 FIESC= 4 FIMM=5 FIG=6 FLSC=7 FS=8 \nFSEAP=9 FSE=10  gata>=11): 2 \n1. stud. Georgiana (F) , 7.72, FEFS  \n2. stud. Iulia (F) , 5.86, FEFS  \n3. stud. Vladimir (M) , 5.19, FEFS  \nAlegeti facultatea(FDSA=1 FEFS=2 FIA=3 FIESC=4 FIMM=5 FIG=6 FLSC=7 FS=8 \nFSEAP=9 FSE=10  gata>=11): 11 \n*** Succes!  \n \nAveti la dispozitie  \nenum Gen  \npublic enum Gen {  \n    F,M; \n} \nenum Facultate  \npublic enum Facultate {  \n    FDSA, FEFS, FIA, FIESC, FIMM, FIG, FLSC",
    "FSEAP=9 FSE=10  gata>=11): 11 \n*** Succes!  \n \nAveti la dispozitie  \nenum Gen  \npublic enum Gen {  \n    F,M; \n} \nenum Facultate  \npublic enum Facultate {  \n    FDSA, FEFS, FIA, FIESC, FIMM, FIG, FLSC, FS, FSEAP, FSE;  \n    private static List<Facultate> l=Arrays.asList(values());  \n    final public static int nrFacultati = l.size();  \n    public static Facultate getFacultate(int i){  \n        return l.get(i);  \n    } \n} \nclass Persoana  \npublic class Persoana {  \n    private static String numeBaieti[]  = {\"Andrei\",\"Liviu\",\"Vasile\",\"George\",  \n\"Lucian\",\"Marius\",\"Ion\",\"Cosmin\",\"Vladimir\",\"Cosmin\",\"Alexandru\",\"Ciprian\"};  \n \n    private static String numeFete[]  = {\"Maria\",\"Mariana\",\"Ana\",\"Lucia\",\"Denisa\",  \n\"Cristina\",\"Ioana\" ,\"Mirabela\",\"Adina\",\"Ligia\",\"Iulia\",\"Georgiana\",\"Angela\",\"Claudia\"\n}; \n    private static Random r = new Random();  \n    // ------------------------------------------------------  \n \n    private String nume;  \n    private Gen gen;  \n    public Persoana(){",
    "\"\n}; \n    private static Random r = new Random();  \n    // ------------------------------------------------------  \n \n    private String nume;  \n    private Gen gen;  \n    public Persoana(){  \n        gen = r.nextInt(1000)  < 511? Gen.F: Gen.M;  \n        nume = gen==Gen.F ? numeFete[ r.nextInt(numeFete.length) ]: \n                            numeBaieti[r.nextInt(numeBaieti.length)];  \n    } \n    public Persoana(String nume, Gen gen) {  \n        this.nume = nume;  \n        this.gen = gen;  \n    } \n    public String getNume() {  \n        return nume;  \n    } \n    public Gen getGen() {  \n        return gen;  \n    } \n    @Override  \n    public String toString() {  \n        return  nume + \" (\" + gen +\") \";  \n    } \n} \n \nClasa Student - incompleta  \npublic class Student  extends Persoana {  \n    private float medieAdmitere;  \n    private Facultate facultate;  \n    @Override  \n    public String toStrin g() { \n        return \"stud.",
    "t - incompleta  \npublic class Student  extends Persoana {  \n    private float medieAdmitere;  \n    private Facultate facultate;  \n    @Override  \n    public String toStrin g() { \n        return \"stud. \" +super.toString()+\", \" + medieAdmitere + \", \" + facultate;  \n    } \n    public Student(String nume, Gen gen, float medieAdmitere, Facultate facultate) {  \n        super(nume,gen);  \n        this.medieAdmitere = medieAdmitere;  \n        this.facultate = facultate;  \n    } \n    public Student(){  \n        // trebuie completat ca sa gen ereze aleator  date pt.  a construi  \n        // un student (medie admitere >=5 si facultate)  \n    } \n    public float getMedieAdmitere() {  \n        return medieAdmitere;  \n    } \n    public Facultate getFacultate() {  \n        return facultate;  \n    } \n    // clasa mai trebuie completat a si cu altele pentru \n    // ca aplicatia sa poata functiona asa cum s -a cerut     \n} \n \nTrebuie sa realiza ti \nCompletarea clasei Student  si scrierea unei noi clase,",
    "// clasa mai trebuie completat a si cu altele pentru \n    // ca aplicatia sa poata functiona asa cum s -a cerut     \n} \n \nTrebuie sa realiza ti \nCompletarea clasei Student  si scrierea unei noi clase, Admitere , care sa efectu eze inmatricularea unui \nnumar maxim de studenti si afisarea rapoartelor  prezentate in e xemplu . \nClasa Admitere  va fi realizata conform design pattern -ului Singleton  (depunctare cu 1p altfel) si va avea \ncel putin urmatoarele metode:  \n• inmatriculeaza( n) – inscrie  maxim  n student i distincti generati aleator  in toate cele 3 registre \n(matricol, colectivul de stud. ai facultati, cel orientat pe gen);  \n• afiseazaStudFacultate()   - afiseaza studentii facultatii indicate de utilizator asa ca in exemplul \nprezentat anterior  \n• main()  \nTEMA ACASA  \nUtilizati structuri diferite pentru colectiile de studenti  si determinati timpul de executie functie de \nnumarul de studenti astfel:  \nFunctia  10000  20000  30000  40000  50000  60000  70000  80000  90000",
    "structuri diferite pentru colectiile de studenti  si determinati timpul de executie functie de \nnumarul de studenti astfel:  \nFunctia  10000  20000  30000  40000  50000  60000  70000  80000  90000  \nInserare           \nconsultare           \neliminare           \ncautare           \nPentru fiecare structura completati cate un astfel de tabel.  \nPunctaj: 2p pentru fiecare structura evaluata.",
    "Laborator 9  \nVocabular - Arbore binar de căutare  \n \nIn acest laborator aveti  de scris o aplicatie grafica  care sa permita efectuarea unor prelucrari asupra \nunui arbore binar de cautare  care memoreaza cuvinte (siruri de caractere) .   \nVeti s crie clasa Panou Grafic  care afiseaza un panou gra fic ca cel din figura urmatoare si care va realiza \nurmatoarele actiuni  comandate prin actionarea unor butoane sau optiuni din ListView : \n• Inserare  –se insereaza in arbore sirul din campul de editare; se afiseaza in TextArea  sirul din \ncampul de editare  urmat de unul din textele urmatoare: “s -a inserat” sau “este deja in arbore ”. \n• Cauta  - se cauta in arbore sirul din campul de editare; se afiseaza in TextArea  “Cauta “ urmat de \nsirul din campul de editare, dupa care se afiseaza rezultatul cautarii “: este in arbore” sau “: nu \neste in arbore” . \n• Elimina  - se elimina din arbore sirul  preluat din campul de editare; se afiseaza in TextArea  \nTextArea  sirul din campul de editare",
    "tatul cautarii “: este in arbore” sau “: nu \neste in arbore” . \n• Elimina  - se elimina din arbore sirul  preluat din campul de editare; se afiseaza in TextArea  \nTextArea  sirul din campul de editare urmat de rezultatul eliminarii “s -a eliminat din arbore” sau \n“nu este in arbore”  \n• Citire fisier  – se va citi un fisier care contine cuvinte pe care le veti insera in arbore; aveti la \ndispozitie fisierul vocabular_fara_diacritice  care contine 7273 cuvinte;  dupa ce s -a citit un fisier \nse va afisa in TextAre a numarul de cuvinte citite  \n• Salvare fisier  – scrie intr -un fiser text cheile din arbore, cate una pe fiecare linie ; se va afisa \nnumarul de chei salvate  \n• RSD, SRD, SDR, Nivele  – (optiuni din ListView) se afiseaza in TextArea item -ul selectat  \n• Info - (optiune din ListView) se afiseaza in TextArea  “Program …  autor …. ” \n \nO sugestie pentru realizarea panoului grafic : scena are ca root un VBox panouGrafic care contine doua \nHBox -uri, ca in figura urmatoare:",
    "tView) se afiseaza in TextArea  “Program …  autor …. ” \n \nO sugestie pentru realizarea panoului grafic : scena are ca root un VBox panouGrafic care contine doua \nHBox -uri, ca in figura urmatoare:  \n \n\nPuteti folosi codul prezentat la curs sau fragmentele de cod de mai jos pe care sa le completati dv.  \npublic class PanouGrafic extends Application { \n   \n private Stage mainStage ; \n private String sirIntrodus =\"\"; \n  \n private TextField nodCrt = new TextField();  \n private Button btnInserare = new Button(\"Inserare\" ); \n // . . .  \n \n private HBox operatiiArbore () { \n    HBox panou = new HBox(10, nodCrt, btnInserare , btnCauta , btnEliminare , \n                                      btnOpen, btnSave);  \n \n    btnInserare .setOnAction(a -> { \n            sirIntrodus = nodCrt.getText().trim();  \n            zonaTextArea .appendText( \"\\n\" + sirIntrodus ); \n            if( sirIntrodus .length() != 0) { \n                zonaTextArea .appendText( arb.add(sirIntrodus ) ?",
    "nodCrt.getText().trim();  \n            zonaTextArea .appendText( \"\\n\" + sirIntrodus ); \n            if( sirIntrodus .length() != 0) { \n                zonaTextArea .appendText( arb.add(sirIntrodus ) ? \"  s-a inserat\"  \n                                                  : \" este deja in arbore\" ); \n                nodCrt.setText( \"\"); \n            } \n         } \n    ); \n \n    btnCauta .setOnAction(a -> { \n        // . . .  \n    }); \n \n    btnEliminare .setOnAction(a -> { \n        // . . .  \n        } \n    }); \n \n    btnOpen.setOnAction(e -> { \n        File fin = deschideFisier( true); \n        if(fin == null) \n            return; \n        try { \n                 // citire fisier . . .  \n            zonaTextArea .setText( \"\\nS-au citit \"+ nr+ \" cuvinte.\" ); \n        } catch (FileNotFoundException fileNotFoundException) {  \n            fileNotFoundException.printStackTrace();  \n        } \n    }); \n    btnSave.setOnAction(e -> { \n            // .",
    "inte.\" ); \n        } catch (FileNotFoundException fileNotFoundException) {  \n            fileNotFoundException.printStackTrace();  \n        } \n    }); \n    btnSave.setOnAction(e -> { \n            // . . .  \n    }); \n    return panou; \n } \n     \n private HBox traversari () { \n    zonaTextArea = getTextArea( \"Operatii:\" ); \n    return new HBox(10, getListaSelectie(), zonaTextArea ); \n } \n \n @Override  \n public void start(Stage primaryStage) {  \n    mainStage = primaryStage;  \n    VBox panouGrafic = new VBox(20, operatiiArbore(), traversari());  \n    panouGrafic .setPadding( new Insets(10)); \n \n    Scene scena = new Scene(panouGrafic , 640, 250); \n \n    primaryStage.setScene( scena); \n    primaryStage.setTitle( \"Arbore binar de cautare\" ); \n    primaryStage.show();  \n } \n \n public static void main(String[] args) {  \n    launch(args); \n } \n} // sfarsit clasa PanouGrafic  \n \n \nFunctia de deschidere fisier utilizabila si pentru citire si scriere.",
    "imaryStage.show();  \n } \n \n public static void main(String[] args) {  \n    launch(args); \n } \n} // sfarsit clasa PanouGrafic  \n \n \nFunctia de deschidere fisier utilizabila si pentru citire si scriere.  \nprivate File deschideFisier (boolean citire) {  \n    FileChooser fileChooser = new FileChooser();  \n    fileChooser .setTitle( \"Deschide fisier cu cuvinte\" ); \n    fileChooser .getExtensionFilters().addAll(  \n            new ExtensionFilter( \"Text Files\" , \"*.txt\"), \n            new ExtensionFilter( \"All Files\" , \"*.*\")); \n    File selectedFile = citire ? fileChooser .showOpenDialog( mainStage ) \n            : fileChooser .showSaveDialog( mainStage ); \n    if (selectedFile != null) { \n        zonaTextArea .appendText( \"\\n\" + selectedFile ); \n    } \n    return selectedFile ; \n} \n \n \nClasa ArboreDeCautare o gasiti in curs.  \nIndicatii:  \n1. Consultati ultimul  cursul in care se prez inta controalele grafice .",
    "ndText( \"\\n\" + selectedFile ); \n    } \n    return selectedFile ; \n} \n \n \nClasa ArboreDeCautare o gasiti in curs.  \nIndicatii:  \n1. Consultati ultimul  cursul in care se prez inta controalele grafice . \n2. Pentru separatorul orizo ntal din ListView  puteti proceda astfel:  \n• Includeti new Separator () in lista observabila de itemi; veti observa o eroare deoarece \nSeparator  nu este < String >; corectati eroarea utilizand un tip generic corespunzator  \n• Inserati cod in Listener  pentru ca atunci cand este selectat separatorul  acesta sa nu produca \nnici o actiune  \nPunctaj  \n- Controalele  grafice din HBox panou – 5p  (1p pt. functionarea corecta a fiecarui buton)  \n- TextArea – 1p \n- Aranjarea grafica conform figurii anterioare ( 1p) \n- Functionare ListView (afisare  minim RSD si SRD  in TextArea) -  2p \nTEMA ACASA  \n \n1. Deoarece in vocabular ul pus la dispozitie cuvintele sunt sortate al fabetic, inserarea lor in aceasta \nordine conduce la un arbore de cautare cu performante O(n).",
    "n TextArea) -  2p \nTEMA ACASA  \n \n1. Deoarece in vocabular ul pus la dispozitie cuvintele sunt sortate al fabetic, inserarea lor in aceasta \nordine conduce la un arbore de cautare cu performante O(n). Acest lucru poate fi observat daca \nveti afisa inaltimea arborelui de cautare  rezultat . Puteti folosi formula recursiva care da inaltime \nunui nod:  \nh(nod) = 1 + max { h(nod.stg), h(nod.dr) }  \nUn arbore vid are inaltimea 0.  \nVeti obser va la citirea fisierul ui vocabular_fara_diacritice   urmatoarele : \n \nPornind de la lista cuvintelor citite din fisier scrieti codul necesar ca sa se obtin a un arbore de \ncautare in care performantele sa fie cat mai apropiate de O(log 2 n). Rezultatul la citirea fisierul ui \nvocabular_fara_diacritice   trebuie sa f ie urmatorul:  \n \n \n2. Dezvoltati operatia de cautare. Daca in TextField se introduc doua siruri separate prin semnul :, \nexemplu as:bal , programul va afisa toate sirurile din arbore care lexicografic s unt >= cu „ as” si \nstrict mai mici",
    "tia de cautare. Daca in TextField se introduc doua siruri separate prin semnul :, \nexemplu as:bal , programul va afisa toate sirurile din arbore care lexicografic s unt >= cu „ as” si \nstrict mai mici decat „ bal”.  \n \n3. Programati jocul Fazan . Veti insera un buton cu aceasta eticheta la actionarea caruia programul \nva alege in mod aleatoriu o litera pe care o va afisa in TextArea . Jucatorul va introduce in TextField \nun cuvant care incepe cu acea litera, iar programul va continua cu un cuvant ca re incepe cu \nultimele 2 litere ale acelui cuvant s.a.m.d.  Bineinteles ca se va juca doar cu cuvintele memorate \nin nodurile arborelui de cautare.  \n \n \nReferinte  \n \nOracle Tutorial JavaFx  - https://docs.oracle.com/javafx/2/  \nOracle - Getting Started with JavaFX – https://docs.oracle.com/javafx/2/get_started/jfxpub -\nget_started.htm  \nOracle – Layouts - https://docs.oracle.com/javafx/2/layout/builtin_layouts.htm#CHDGHCDG  \n \nTutorialspoint - Learn JavaFX Absolute Beginners - \nhttps://ww",
    "vafx/2/get_started/jfxpub -\nget_started.htm  \nOracle – Layouts - https://docs.oracle.com/javafx/2/layout/builtin_layouts.htm#CHDGHCDG  \n \nTutorialspoint - Learn JavaFX Absolute Beginners - \nhttps://www.tutorialspoint.com/javafx/index.htm  \n \nControale grafice:  \nOracle - https://docs.oracle.com/javafx/2/ui_cont rols/jfxpub -ui_controls.htm  \nTutorialspoint – https://www.tutorialspoint.com/javafx/javafx_ui_controls.htm"
  ],
  "metadata": [
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 1,
      "chunk_length": 939
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 2,
      "chunk_length": 996
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 3,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 4,
      "chunk_length": 983
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 5,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 6,
      "chunk_length": 999
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 7,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 8,
      "chunk_length": 917
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 9,
      "chunk_length": 991
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 10,
      "chunk_length": 999
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 11,
      "chunk_length": 906
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 12,
      "chunk_length": 934
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 13,
      "chunk_length": 924
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 14,
      "chunk_length": 957
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 15,
      "chunk_length": 924
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 16,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 17,
      "chunk_length": 999
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 18,
      "chunk_length": 998
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 19,
      "chunk_length": 999
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 20,
      "chunk_length": 999
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 21,
      "chunk_length": 976
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 22,
      "chunk_length": 993
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 23,
      "chunk_length": 998
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 24,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 25,
      "chunk_length": 925
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 26,
      "chunk_length": 999
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 27,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 28,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 29,
      "chunk_length": 990
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 30,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 31,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 32,
      "chunk_length": 999
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 33,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 34,
      "chunk_length": 999
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 35,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 36,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 37,
      "chunk_length": 994
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 38,
      "chunk_length": 991
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 39,
      "chunk_length": 901
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 40,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 41,
      "chunk_length": 915
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 42,
      "chunk_length": 1000
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 43,
      "chunk_length": 999
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 44,
      "chunk_length": 998
    },
    {
      "source": "comparareObiecte.pdf",
      "chunk_index": 45,
      "chunk_length": 726
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 1,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 2,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 3,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 4,
      "chunk_length": 950
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 5,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 6,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 7,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 8,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 9,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 10,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 11,
      "chunk_length": 999
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 12,
      "chunk_length": 999
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 13,
      "chunk_length": 1000
    },
    {
      "source": "Curs1_SDJava.pdf",
      "chunk_index": 14,
      "chunk_length": 638
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 1,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 2,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 3,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 4,
      "chunk_length": 959
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 5,
      "chunk_length": 999
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 6,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 7,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 8,
      "chunk_length": 933
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 9,
      "chunk_length": 999
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 10,
      "chunk_length": 920
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 11,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 12,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 13,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 14,
      "chunk_length": 948
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 15,
      "chunk_length": 999
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 16,
      "chunk_length": 999
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 17,
      "chunk_length": 999
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 18,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 19,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 20,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 21,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 22,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 23,
      "chunk_length": 989
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 24,
      "chunk_length": 999
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 25,
      "chunk_length": 998
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 26,
      "chunk_length": 996
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 27,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 28,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 29,
      "chunk_length": 1000
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 30,
      "chunk_length": 854
    },
    {
      "source": "Curs2_3_SDJava.pdf",
      "chunk_index": 31,
      "chunk_length": 53
    },
    {
      "source": "Curs3_SDAJava.pdf",
      "chunk_index": 0,
      "chunk_length": 999
    },
    {
      "source": "Curs3_SDAJava.pdf",
      "chunk_index": 1,
      "chunk_length": 999
    },
    {
      "source": "Curs3_SDAJava.pdf",
      "chunk_index": 2,
      "chunk_length": 1000
    },
    {
      "source": "Curs3_SDAJava.pdf",
      "chunk_index": 3,
      "chunk_length": 1000
    },
    {
      "source": "Curs3_SDAJava.pdf",
      "chunk_index": 4,
      "chunk_length": 1000
    },
    {
      "source": "Curs3_SDAJava.pdf",
      "chunk_index": 5,
      "chunk_length": 477
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 0,
      "chunk_length": 913
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 1,
      "chunk_length": 964
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 2,
      "chunk_length": 1000
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 3,
      "chunk_length": 1000
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 4,
      "chunk_length": 998
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 5,
      "chunk_length": 930
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 6,
      "chunk_length": 947
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 7,
      "chunk_length": 999
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 8,
      "chunk_length": 1000
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 9,
      "chunk_length": 1000
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 10,
      "chunk_length": 924
    },
    {
      "source": "Curs5_SDJava_Collection.pdf",
      "chunk_index": 11,
      "chunk_length": 638
    },
    {
      "source": "Curs6_SDJava_DequeIterator.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "Curs6_SDJava_DequeIterator.pdf",
      "chunk_index": 1,
      "chunk_length": 998
    },
    {
      "source": "Curs6_SDJava_DequeIterator.pdf",
      "chunk_index": 2,
      "chunk_length": 775
    },
    {
      "source": "ExpresiiLambda.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "ExpresiiLambda.pdf",
      "chunk_index": 1,
      "chunk_length": 1000
    },
    {
      "source": "ExpresiiLambda.pdf",
      "chunk_index": 2,
      "chunk_length": 999
    },
    {
      "source": "ExpresiiLambda.pdf",
      "chunk_index": 3,
      "chunk_length": 1000
    },
    {
      "source": "ExpresiiLambda.pdf",
      "chunk_index": 4,
      "chunk_length": 1000
    },
    {
      "source": "ExpresiiLambda.pdf",
      "chunk_index": 5,
      "chunk_length": 963
    },
    {
      "source": "ExpresiiLambda.pdf",
      "chunk_index": 6,
      "chunk_length": 163
    },
    {
      "source": "Java_9.pdf",
      "chunk_index": 0,
      "chunk_length": 966
    },
    {
      "source": "Java_9.pdf",
      "chunk_index": 1,
      "chunk_length": 998
    },
    {
      "source": "Java_9.pdf",
      "chunk_index": 2,
      "chunk_length": 999
    },
    {
      "source": "Java_9.pdf",
      "chunk_index": 3,
      "chunk_length": 999
    },
    {
      "source": "Java_9.pdf",
      "chunk_index": 4,
      "chunk_length": 882
    },
    {
      "source": "Java_9.pdf",
      "chunk_index": 5,
      "chunk_length": 81
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 985
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 1000
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 935
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 3,
      "chunk_length": 920
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 4,
      "chunk_length": 987
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 5,
      "chunk_length": 951
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 6,
      "chunk_length": 990
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 7,
      "chunk_length": 964
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 8,
      "chunk_length": 1000
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 9,
      "chunk_length": 999
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 10,
      "chunk_length": 999
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 11,
      "chunk_length": 999
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 12,
      "chunk_length": 1000
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 13,
      "chunk_length": 904
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 14,
      "chunk_length": 998
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 15,
      "chunk_length": 999
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 16,
      "chunk_length": 999
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 17,
      "chunk_length": 999
    },
    {
      "source": "L10_Java.pdf",
      "chunk_index": 18,
      "chunk_length": 476
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 974
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 968
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 945
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 3,
      "chunk_length": 998
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 4,
      "chunk_length": 1000
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 5,
      "chunk_length": 994
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 6,
      "chunk_length": 998
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 7,
      "chunk_length": 998
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 8,
      "chunk_length": 1000
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 9,
      "chunk_length": 985
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 10,
      "chunk_length": 910
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 11,
      "chunk_length": 1000
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 12,
      "chunk_length": 922
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 13,
      "chunk_length": 976
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 14,
      "chunk_length": 967
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 15,
      "chunk_length": 1000
    },
    {
      "source": "L12_Java.pdf",
      "chunk_index": 16,
      "chunk_length": 355
    },
    {
      "source": "L1_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "L1_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 920
    },
    {
      "source": "L1_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 502
    },
    {
      "source": "L2_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 998
    },
    {
      "source": "L2_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 1000
    },
    {
      "source": "L2_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 1000
    },
    {
      "source": "L2_Java.pdf",
      "chunk_index": 3,
      "chunk_length": 1000
    },
    {
      "source": "L2_Java.pdf",
      "chunk_index": 4,
      "chunk_length": 998
    },
    {
      "source": "L2_Java.pdf",
      "chunk_index": 5,
      "chunk_length": 999
    },
    {
      "source": "L2_Java.pdf",
      "chunk_index": 6,
      "chunk_length": 849
    },
    {
      "source": "L2_Java.pdf",
      "chunk_index": 7,
      "chunk_length": 50
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 925
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 981
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 1000
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 3,
      "chunk_length": 912
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 4,
      "chunk_length": 1000
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 5,
      "chunk_length": 926
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 6,
      "chunk_length": 1000
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 7,
      "chunk_length": 905
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 8,
      "chunk_length": 1000
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 9,
      "chunk_length": 814
    },
    {
      "source": "L3_Java.pdf",
      "chunk_index": 10,
      "chunk_length": 14
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 1000
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 1000
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 3,
      "chunk_length": 1000
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 4,
      "chunk_length": 1000
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 5,
      "chunk_length": 941
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 6,
      "chunk_length": 1000
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 7,
      "chunk_length": 999
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 8,
      "chunk_length": 979
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 9,
      "chunk_length": 1000
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 10,
      "chunk_length": 935
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 11,
      "chunk_length": 1000
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 12,
      "chunk_length": 1000
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 13,
      "chunk_length": 958
    },
    {
      "source": "L4_Java.pdf",
      "chunk_index": 14,
      "chunk_length": 158
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 3,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 4,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 5,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 6,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 7,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 8,
      "chunk_length": 982
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 9,
      "chunk_length": 994
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 10,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 11,
      "chunk_length": 997
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 12,
      "chunk_length": 976
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 13,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 14,
      "chunk_length": 956
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 15,
      "chunk_length": 940
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 16,
      "chunk_length": 1000
    },
    {
      "source": "L5_Java.pdf",
      "chunk_index": 17,
      "chunk_length": 348
    },
    {
      "source": "L6_java.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "L6_java.pdf",
      "chunk_index": 1,
      "chunk_length": 861
    },
    {
      "source": "L6_java.pdf",
      "chunk_index": 2,
      "chunk_length": 61
    },
    {
      "source": "L7_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 974
    },
    {
      "source": "L7_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 986
    },
    {
      "source": "L7_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 935
    },
    {
      "source": "L7_Java.pdf",
      "chunk_index": 3,
      "chunk_length": 868
    },
    {
      "source": "L7_Java.pdf",
      "chunk_index": 4,
      "chunk_length": 68
    },
    {
      "source": "L8_2_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 999
    },
    {
      "source": "L8_2_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 942
    },
    {
      "source": "L8_2_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 947
    },
    {
      "source": "L8_2_Java.pdf",
      "chunk_index": 3,
      "chunk_length": 917
    },
    {
      "source": "L8_2_Java.pdf",
      "chunk_index": 4,
      "chunk_length": 117
    },
    {
      "source": "L8_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "L8_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 1000
    },
    {
      "source": "L8_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 925
    },
    {
      "source": "L8_Java.pdf",
      "chunk_index": 3,
      "chunk_length": 1000
    },
    {
      "source": "L8_Java.pdf",
      "chunk_index": 4,
      "chunk_length": 989
    },
    {
      "source": "L8_Java.pdf",
      "chunk_index": 5,
      "chunk_length": 937
    },
    {
      "source": "L8_Java.pdf",
      "chunk_index": 6,
      "chunk_length": 1000
    },
    {
      "source": "L8_Java.pdf",
      "chunk_index": 7,
      "chunk_length": 997
    },
    {
      "source": "L8_Java.pdf",
      "chunk_index": 8,
      "chunk_length": 390
    },
    {
      "source": "L9_Java.pdf",
      "chunk_index": 0,
      "chunk_length": 1000
    },
    {
      "source": "L9_Java.pdf",
      "chunk_index": 1,
      "chunk_length": 996
    },
    {
      "source": "L9_Java.pdf",
      "chunk_index": 2,
      "chunk_length": 977
    },
    {
      "source": "L9_Java.pdf",
      "chunk_index": 3,
      "chunk_length": 955
    },
    {
      "source": "L9_Java.pdf",
      "chunk_index": 4,
      "chunk_length": 954
    },
    {
      "source": "L9_Java.pdf",
      "chunk_index": 5,
      "chunk_length": 919
    },
    {
      "source": "L9_Java.pdf",
      "chunk_index": 6,
      "chunk_length": 998
    },
    {
      "source": "L9_Java.pdf",
      "chunk_index": 7,
      "chunk_length": 1000
    },
    {
      "source": "L9_Java.pdf",
      "chunk_index": 8,
      "chunk_length": 1000
    },
    {
      "source": "L9_Java.pdf",
      "chunk_index": 9,
      "chunk_length": 421
    }
  ]
}